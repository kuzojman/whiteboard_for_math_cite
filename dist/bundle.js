/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./public/frontend.js":
/*!****************************!*\
  !*** ./public/frontend.js ***!
  \****************************/
/***/ (() => {

eval("const canvas = new fabric.Canvas(document.getElementById(\"canvasId\"),{\n\n  allowTouchScrolling: true,\n  preserveObjectStacking: true,\n});\n\n\n//const socket = io('http://localhost:3000',{transports:['websocket']});\n\n// const socket = io('http://192.168.1.46:3000',{transports:['websocket']});\n\nconst socket = io(witeboardServiceHost,{transports:['websocket']});\n\n// const socket = io();\n\n// конец принятых сообщений\nconst END_OF_RECIEVE_OBJECTS = 1;\n\nconst board_id = get_board_id() || 1;\n\nlet isRendering = false;\nconst render = canvas.renderAll.bind(canvas);\n\ncanvas.renderAll = () => {\n    if (!isRendering) {\n        isRendering = true;\n        requestAnimationFrame(() => {\n          render();\n          isRendering = false;\n        });\n    }\n};\n\nfabric.util.object.extend(fabric.Object.prototype, {\n  transform: function(ctx, fromLeft) {\n    \n    // if (this.group && !this.group._transformDone && this.group === this.canvas._activeGroup) {\n    //   this.group.transform(ctx);\n    // }\n    var center = fromLeft ? this._getLeftTopCoords() : this.getCenterPoint();\n    // ADDED CODE FOR THE ANSWER\n    // console.log(this.ignoreZoom && !this.group && this.canvas);\n    if (this.ignoreZoom && !this.group && this.canvas) {\n      var zoom = 1 / this.canvas.getZoom();\n      // ctx.scale(zoom, zoom);\n      // ctx.webkitImageSmoothingEnabled = false;\n      // ctx.mozImageSmoothingEnabled = false;\n      // ctx.imageSmoothingEnabled = false;\n      // if ( this.w === undefined ){\n      //   this.w = this.width;\n      //   this.h = this.height;\n      // }\n      // let   w = this.w * zoom,\n      //       h = this.h * zoom,\n      //       s = this.strokeWidth;\n      // console.log( this.w, this.h, zoom, w,h, this._objects );\n      if ( this._objects && this._objects.length >0 ){\n        this._objects.forEach(el => {\n          if ( el.w === undefined ){\n            el.w = el.width;\n            el.h = el.height;\n          }\n          if ( el.text && el.text!='' && el.t === undefined ){\n            el.t = el.top\n            el.f = el.fontSize\n            el.l = el.left\n          }\n          if ( el.radius && el.radius>0 && el.r === undefined ){\n            el.r = el.radius\n          }\n          let   t_ = el.t * zoom,\n            f_ = el.f * zoom,\n            l_ = el.l * zoom,\n            r_ = el.r * zoom;\n          if ( el.radius && el.radius>0){\n            el.set({\n              'radius'     : r_,\n            })  \n          }\n          if ( el.text && el.text!='' ){\n            el.set({\n              'fontSize'  : f_,\n              'top'       : t_,\n              'left'      : l_,\n            })  \n          }\n          \n        });\n      }\n      // ctx.translate(center.x*this.canvas.getZoom(), center.y*this.canvas.getZoom());\n      // ctx.translate(center.x, center.y);\n      var needFullTransform = (this.group && !this.group._transformDone) ||\n        (this.group && this.canvas && ctx === this.canvas.contextTop);\n      var m = this.calcTransformMatrix(!needFullTransform);\n      ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);\n      // this.set({\n      //     'height'     : w,\n      //     'width'      : h,\n      //     'zoomX'     : 1,\n      //     'zoomY'     : 1,\n      //     'scaleX'     : 1,\n      //     'scaleY'     : 1,\n      // });\n      // console.log(this);\n      // ctx.translate(0.5, 0.5);\n      return;\n    }\n    // }else{\n    //   ctx.translate(center.x, center.y);\n    // }\n    // END OF ADDED CODE FOR THE ANSWER\n    // this.angle && ctx.rotate(degreesToRadians(this.angle));\n    // ctx.scale(\n    //   this.scaleX * (this.flipX ? -1 : 1),\n    //   this.scaleY * (this.flipY ? -1 : 1)\n    // );\n    // this.skewX && ctx.transform(1, 0, Math.tan(degreesToRadians(this.skewX)), 1, 0, 0);\n    // this.skewY && ctx.transform(1, Math.tan(degreesToRadians(this.skewY)), 0, 1, 0, 0);\n\n    var needFullTransform = (this.group && !this.group._transformDone) ||\n        (this.group && this.canvas && ctx === this.canvas.contextTop);\n    var m = this.calcTransformMatrix(!needFullTransform);\n    ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);\n\n  }\n});\n\n// Передача обновлённого состояния canvas'а на сервер через webworker\n// В случае добавления или удаления элементов передаётся разница между\n// предыдущим и текущим состоянием canvas._objects\n\nlet last_canvas_object = 0;\nlet max_items_to_add = 5;\nlet clear_sent = false;\nlet canvas_sent = false;\n\nlet send_part_events = []\nlet recive_part_events = []\n\n// Строка в массив байт по 2 байта на символ\n// Первыми двумя записываем board_id\n\nasync function str2ab(str) {\n    let buf = new ArrayBuffer(str.length*2);\n    let buf_view = new Uint16Array(buf);\n\n    for (let i = 0, str_len = str.length; i < str_len; i++) {\n        if (i === 0) buf_view[i] = board_id.toString().charCodeAt(0);\n        else buf_view[i] = str.charCodeAt(i);\n    }\n\n    return buf;\n}\n\nconst JSONStringifyAsync = (data, replacer = null, space = null) => {\n    return new Promise((resolve, reject) => {\n        try {\n            let output = JSON.stringify(data, replacer, space);\n            resolve(output);\n        } catch (error) {\n            reject(error);\n        }\n    });\n};\n\nconst JSONParseAsync = (data, reviver = null) => {\n    return new Promise((resolve, reject) => {\n        try {\n            let output = JSON.parse(data, reviver);\n            resolve(output);\n        } catch (error) {\n            reject(error);\n        }\n    });\n}\n\n// Вызов webworker\n\nasync function callWorker(worker) {\n    try {\n        let len = canvas._objects.length;\n\n        if (!canvas_sent) {\n            worker.postMessage({act: \"init\", canvas: await JSONStringifyAsync(canvas.toJSON())});\n            canvas_sent = true;\n        } else {\n            // Если добавлены элементы\n            if (last_canvas_object <= len) {\n                let start = (last_canvas_object === 0) ? 0 : last_canvas_object\n                let items_to_add = len - last_canvas_object\n\n                if (items_to_add >= max_items_to_add) {\n                    items_to_add = max_items_to_add\n                }\n\n                let end = start + items_to_add\n\n                //console.log(\"Current len: \" + canvas._objects.length)\n                //console.log(\"Last added: \" + last_canvas_object)\n                //console.log(\"Items to add: \" + items_to_add)\n                //console.log(\"End: \" + end)\n\n                if (end <= len && items_to_add !== 0) {\n                    let _data = await JSONStringifyAsync(canvas._objects.slice(start, end));\n                    let buf = await str2ab(\"[\" + _data + \"]\")\n                    last_canvas_object = end;\n                    //console.log(start, end)\n                    worker.postMessage(buf, [buf]);\n                }\n            }\n\n            // Изменение объектов\n            if (send_part_events.length >= 0) {\n                let interval = setInterval(() => {\n                    let e = send_part_events.shift();\n                    if (e && e.target && e.target._objects) {\n                        let data = {objects: []};\n                        if (e && e.transform && e.transform.target && e.transform.target.type == 'group') {\n                            let object_index = find_object_index(e.transform.target);\n                            e.transform.target.object_index = find_object_index(e.transform.target);\n                            data.objects.push({\n                                id: e.transform.target.id,\n                                index: object_index,\n                                object: e.transform.target,\n                                top_all: canvas._objects[object_index].top,\n                                left_all: canvas._objects[object_index].left,\n                                angle: canvas._objects[object_index].angle,\n                                scaleX: canvas._objects[object_index].scaleX,\n                                scaleY: canvas._objects[object_index].scaleY,\n                            })\n                        } else {\n                            e.transform.target._objects.forEach((object) => {\n                                let object_index = find_object_index(object);\n                                object.object_index = object_index;\n                                data.objects.push({\n                                    id: object.id,\n                                    object: object,\n                                    index: object_index,\n                                    top_all: canvas._objects[object_index].top,\n                                    left_all: canvas._objects[object_index].left,\n                                    angle: canvas._objects[object_index].angle,\n                                    scaleX: canvas._objects[object_index].scaleX,\n                                    scaleY: canvas._objects[object_index].scaleY,\n                                });\n                            });\n                        }\n                        setTimeout(() => {\n                            socket.emit(\"object:modified\", data);\n                        }, 100);\n                    } else if (e && e.target) {\n                        let object_index = find_object_index(e.target);\n\n                        e.target.object_index = object_index;\n                        setTimeout(() => {\n                            socket.emit(\"object:modified\", {\n                                //object: e.target,\n                                id: canvas._objects[object_index].id,\n                                object: canvas._objects[object_index],\n                                index: object_index,\n                            });\n                        }, 100);\n                    }\n                }, 100);\n                if (send_part_events.length === 0) clearInterval(interval)\n            }\n\n            if (recive_part_events.length >= 0) {\n                let interval = setInterval(async () => {\n                    let e = recive_part_events.shift();\n                    if (e && e.objects) {\n                        for (const object of e.objects) {\n                            //let d = canvas.item(object.index);\n                            let d = canvas._objects.find(item => item.id == object.id);\n                            if (!d) {\n                                continue;\n                            }\n                            d.set({\n                                top: object.top_all, //+object.object.top,\n                                left: object.left_all, //+object.object.left\n                                angle: object.angle,\n                                scaleX: object.scaleX,\n                                scaleY: object.scaleY,\n                            });\n                        }\n                        let buf = await str2ab(\"[\" + \"update_many\" + e.objects + \"]\");\n                        worker.postMessage(buf, [buf]);\n                    } else if (e && e.object) {\n                        //let d = canvas.item(e.index);\n                        let d = canvas._objects.find(item => item.id == e.id);\n                        //d.set(e.object);\n                        if (!d) {\n                            return false\n                        }\n                        d.set({\n                            top: e.object.top, //+object.object.top,\n                            left: e.object.left, //+object.object.left\n                            angle: e.object.angle,\n                            scaleX: e.object.scaleX,\n                            scaleY: e.object.scaleY,\n                        });\n                        worker.postMessage({act: \"update_one\", id: e.id.toString(), el: d});\n                    }\n                }, 200);\n                if (recive_part_events.length === 0) clearInterval(interval);\n            }\n\n            // Если доска очищена\n            if (len === 0 && !clear_sent) {\n                worker.postMessage({act: \"clear\"});\n                clear_sent = true;\n            }\n        }\n\n        worker.onmessage = e => {\n            console.log(e)\n            worker.terminate()\n        }\n\n        worker.onerror = e => {\n          console.error(e)\n        }\n    } catch (e) {\n        console.log(e)\n    }\n}\n\n// window.onload = async () => {\n//     const worker = new Worker('./workers/save_board_job.js', /*{ type: \"module\" }*/);\n//     setInterval(async () => {\n//         await callWorker(worker);\n//     }, 500)\n//     window.onunload = () => {worker.terminate()}\n// }\n\n// для продакшна надо оставить пустым\nlet serverHostDebug = siteAddress //\"https://kuzovkin.info\"  //\n// есть ли доступ к доске? и в качестве какой роли\nlet accessBoard = false;\n// ожидаем ли мы одобрения от учителя?\nlet waitingOverlay = false;\n\n\nconst canvasbg = new fabric.Canvas(document.getElementById(\"canvasId_bg\"),{\n  preserveObjectStacking: true,\n  containerClass: 'absolute-container'\n});\n\nlet selectionTimer = null;\n\nlet selectedTool = \"\";\n\nlet panningGesture = false;\n\n/**\n * Очистка доски\n * @broadcast - оповещаем ли всех, о том что надо очищать доску\n */\nfunction clearBoard(broadcast=true){\n  // выпускаем сигнал на удаление\n  if ( broadcast ){\n    socket.emit(\"canvas:clear\",board_id);\n  }\n\n  canvas.renderOnAddRemove = false;\n  var canvasObjects = canvas.getObjects();\n  for (let i = 0; i < canvasObjects.length; i++) {\n    const element = canvasObjects[i];\n    // удаляем все объекты кроме курсоров\n    if ( !element.socket_id ){\n      canvas.remove(element);\n    }\n  }\n\n  canvas.renderOnAddRemove = true;\n  canvas.renderAll();\n  clear_sent = 0;\n\n  if ( broadcast ){\n   socket.emit(\"canvas_save_to_json\", {\"board_id\": board_id, \"canvas\": serialize_canvas(canvas)});\n  }\n}\n\n/**\n * Перенаправление в личный кабинет\n */\nfunction goUserBoard(){\n  window.location.href = siteAddress + backUrl;\n}\n\n/**\n * Центрируем объект по центру экрана\n * @param {*} obj \n */\nfunction setObjectToCanvasCenter(obj){\n  if (obj){\n    let w2 = obj.width/2\n    let h2 = obj.height/2\n    obj.set({\n      top: canvas.vptCoords.tl.y+(canvas.vptCoords.br.y - canvas.vptCoords.tl.y)/2-h2,\n      left: canvas.vptCoords.tl.x+(canvas.vptCoords.br.x - canvas.vptCoords.tl.x)/2-w2,\n    });\n  }\n}\n\n/**\n *  Устанавливаем курсор по выбранному инструменты\n * @param {*} curname название инструмента и файла с курсором\n */\nfunction setCursor(curname){\n  canvas.hoverCursor = 'url(\"./icons/'+curname+'.cur\"), auto';\n  canvas.defaultCursor = 'url(\"./icons/'+curname+'.cur\"), auto';\n  canvas.freeDrawingCursor = 'url(\"./icons/'+curname+'.cur\"), auto';\n}\n\n/**\n * Нажатие на кнопку выбора инструмента\n */\nfunction selectTool(event){\n    let currentButton = event.target.closest('.tool-panel__item-button');\n    let notCurrentButton = event.target.closest('.sub-tool-panel__item-button');\n    if ( notCurrentButton ){\n      currentButton = notCurrentButton;\n    }\n    if( currentButton) {\n\n      let currentAction = currentButton.dataset.tool;\n\n      if ( currentAction ){\n        if (currentAction==selectedTool){\n          selectedTool=\"\"\n        }else{\n          selectedTool=currentAction\n        }\n      }\n      // console.log(selectedTool);\n      // если выбрано лезвие, то меняем курсор\n      if ( selectedTool=='blade' || selectedTool=='freedraw' ){\n        setCursor(selectedTool);\n      }else{\n        canvas.hoverCursor = 'auto';\n        canvas.freeDrawingCursor = 'auto';\n        canvas.defaultCursor = 'move';\n      }\n\n      let siblings = getSiblings(currentButton);\n      if ( siblings.length>0 ){\n        if ( siblings.map(e=>e.classList).indexOf('sub-tool-panel') ){\n          if(selectedButton === currentButton) {\n            toolPanel.classList.toggle('full-screen');\n          }else{\n            toolPanel.classList.add('full-screen');\n          }\n        }else{\n          toolPanel.classList.remove('full-screen')\n        }\n      }else{\n        toolPanel.classList.remove('full-screen')\n      }\n    }else{\n      toolPanel.classList.remove('full-screen')\n    }\n\n    if(selectedButton === currentButton && selectedButton) {\n        if ( !selectedButton.classList.contains('js-modal-trigger') && !selectedButton.classList.contains(\"disable\") ){\n          selectedButton.classList.toggle('settings-panel__button_active');\n        }\n    } else {\n        if(currentButton) {\n          if ( !currentButton.classList.contains('js-modal-trigger') && !currentButton.classList.contains(\"disable\")  ){\n            currentButton.classList.toggle('settings-panel__button_active');\n          }\n        }\n        if(selectedButton ) {\n            selectedButton.classList.remove('settings-panel__button_active');\n        }\n        selectedButton = currentButton;\n    }\n\n}\n\ncanvas.on('touch:gesture',function(e){\n  isGestureEvent = true;\n  // console.log(selectedTool);\n  // console.log(e.self.touches, e.self.scale, currentValueZoom);\n  if ( e.self.touches!==undefined && e.self.touches.length==2 && selectedTool=='moving' ){\n    // this.selection = false;\n    var lPinchScale = e.self.scale;  \n    // var scaleDiff = (lPinchScale -1)/10 + 1;  // Slow down zoom speed    \n    const delta = e.self.scale-currentValueZoom;\n    // alert(JSON.stringify(e.self));\n    // console.log('delta',delta);\n    handleScale(delta);\n    as.textContent = (currentValueZoom * 100).toFixed(0)+'%';\n    canvas.zoomToPoint({x:e.self.x, y: e.self.y},currentValueZoom);\n    canvasbg.zoomToPoint({x:e.self.x, y: e.self.y},currentValueZoom);\n    // console.log({x:e.self.x, y: e.self.y},currentValueZoom);\n    // clearTimeout(selectionTimer)\n    // console.log(state);\n    if ( !panningGesture ){\n      // canvas.toggleDragMode(true)\n      panningGesture = true\n    }\n    \n    // selectionTimer = setTimeout( ()=>canvas.toggleDragMode(true) , 500);\n    clearTimeout(selectionTimer)\n    selectionTimer = setTimeout( ()=>panningGesture = false , 50);\n    this.selection = false;\n  }\n  \n});\n\nconst MAX_ZOOM_IN  = 4;\nconst MAX_ZOOM_OUT = 0.05;\nconst SCALE_STEP = 0.05;\n\nlet currentValueZoom = 1;\n\nlet currentRadiusCursor = 10;\nlet currentTextCursor   = 14;\n// когда получили первые данные\nlet takedFirstData = false;\nlet allReceivedObjects = false;\nconst cursorUser = createCursor()\n\nfunction decreaseRecievedObjects(){\n  if ( allReceivedObjects<=0 ){\n    takedFirstData=true;\n    return END_OF_RECIEVE_OBJECTS\n  }\n  allReceivedObjects-=1;\n  return false;\n}\n\nfunction createCursor(){\n  let curs_ =  new fabric.Circle({              // Представление курсора\n    radius: currentRadiusCursor/ (currentValueZoom),\n    fill: 'red',\n    left: 0,\n    top: 0,\n    originX: 'center',\n    originY: 'center',\n    erasable:false,\n    selectable:false,\n    objectCaching: false\n  });\n  let text_ = new fabric.Text(\"Username\", {\n    fontFamily: 'Calibri',\n    fontSize: 14/ (currentValueZoom),\n    textAlign: 'left',\n    originX: 'center',\n    originY: 'center',\n    erasable:false,\n    selectable:false,\n    left: currentRadiusCursor*2,\n    top: currentRadiusCursor*2,\n    objectCaching: false  });\n  let cursor_ = new fabric.Group([curs_,text_],{\n    left: 1,\n    top: 1,\n    erasable:false,\n    selectable:false,\n    cursor:true,\n  })\n  return cursor_\n}\n\n\ncanvas.on('mouse:wheel',function(opt){\n  const delta =opt.e.deltaY;\n  handleScale(delta);\n  as.textContent = (currentValueZoom * 100).toFixed(0)+'%';\n  let coursours =  canvas._objects.filter(item=>item.socket_id || item.clone_id);\n  coursours.forEach(cursor =>{\n    cursor.zoomX = 1;\n    cursor.zoomY = 1;\n    //cursor._objects[0].radius =   10 / (currentValueZoom );\n    //cursor._objects[1].fontSize = 14 / (currentValueZoom );\n    cursor._objects[0].set({\n      radius:10 / (currentValueZoom ),\n\n    })\n    cursor._objects[1].set({\n      fontSize : 14 / (currentValueZoom )\n    })\n  })\n  canvas.renderAll();\n  canvas.zoomToPoint({x:opt.e.offsetX, y: opt.e.offsetY},currentValueZoom);\n  canvasbg.zoomToPoint({x:opt.e.offsetX, y: opt.e.offsetY},currentValueZoom);\n  opt.e.preventDefault();\n  opt.e.stopPropagation();\n})\n\nconst toolPanel = document.querySelector('.tool-panel');\n\nconst handleChangeActiveButton = (newActiveButton) => {\n  let button = newActiveButton;\n  if ( !selectedButton.classList.contains(\"disable\") ){\n    selectedButton.classList.remove('settings-panel__button_active');\n  }\n  toolPanel.classList.remove('full-screen');\n  if(button){\n      selectedButton = button;\n      if ( !selectedButton.classList.contains(\"disable\") ){\n        selectedButton.classList.add('settings-panel__button_active');\n      }\n      toolPanel.classList.add('full-screen');\n  }\n}     // Смена выбранной кнопки на другую актинвую\n\n\nconst handleDownKeySpace = (event) => {\n  if (event.code === 'Space' && !event.repeat && !isDown) {\n      event.preventDefault();\n      canvas.isDrawingMode = false;\n      isCursorMove = true;\n      canvas.toggleDragMode();\n      handleChangeActiveButton(buttonCursorMove)\n\n  }\n}           // Нажатие на пробел\nconst handleUpKeySpace = (event) => {\n  if (event.code === 'Space' && !isDown) {\n    isCursorMove = false;\n    canvas.selection = true;\n    event.preventDefault();\n    canvas.toggleDragMode();\n    handleChangeActiveButton()\n\n    if(!isCursorMove) {\n        document.body.addEventListener('keydown', handleDownKeySpace)\n    }\n  }\n}             // Отпускание пробела\n\n\nlet cursorCoordinateOtherUsers;\n\nconst handleMouseMovement = (event) => {\n\n  if (canvasDragModeEnabled){\n    let coursours =  canvas._objects.filter(item=>item.socket_id)\n    coursours.forEach(cursor =>{\n      checkCursorClones({\n        cursorCoordinates:{x:cursor.left,y:cursor.top},\n        userId:cursor.socket_id,\n        existing_coursor:cursor\n      })\n    })\n\n  }\n  const cursorCoordinate = canvas.getPointer(event.e);\n  let data = {\n      userId: socket.id,\n      coords: cursorCoordinate,\n  }\n  socket.emit('cursor-data', data);\n}   \n\n/**\n * Ловим курсор когда он вышел за пределы канваса\n * @param {*} ev \n */\nconst handleMouseOut = (ev)=>{\n  if (ev.e.type=='mouseout'){\n    const cursorCoordinate = canvas.getPointer(ev.e);\n    let w = canvas.getWidth()\n    let h = canvas.getHeight()    \n    let data = {\n        userId: socket.id,\n        coords: cursorCoordinate,\n        cursor:'leave'\n    }\n    //socket.emit('cursor-data', data);\n  }\n}\n\nlet colors = ['#ff0000','#0f71d3','#14ff00'];\nlet color_index =0;                                            // Курсор\nlet moveCursorsToFront = false;\nlet createdCursors = {}\nconst getCursorData = (data) => {\n  // console.log(data);\n  let existing_coursor = canvas._objects.find(item=>item.socket_id==data.userId)\n  if(!existing_coursor )\n  {\n    if(createdCursors[data.userId]) return false;\n    let copyCursorUser = createCursor(); //CursorUser\n    createdCursors[data.userId]=true;\n    copyCursorUser.socket_id=data.userId;\n    console.log('creating_new_coursour', data,existing_coursor,canvas._objects.length,copyCursorUser);\n    copyCursorUser.item(0).fill = colors[color_index];\n    copyCursorUser.item(1).text = data.username || \"unknown\"\n    color_index++;\n    if(!colors[color_index]){\n      color_index=0;\n    }\n    //cursorUser.left = data.cursorCoordinates.x\n       //canvas.sendToBack(cursorUser);\n\n    canvas._objects.push(copyCursorUser);\n\n    existing_coursor = copyCursorUser;\n    \n  }else{\n    \n    // console.log(h,w,data.cursorCoordinates);\n\n\n    existing_coursor.set({\n      top:  data.cursorCoordinates.y,\n      left: data.cursorCoordinates.x,\n      opacity: 1\n    }); \n    if ( data.cursor!==undefined && data.cursor=='leave' ){\n      existing_coursor.set({\n        opacity: 0.2\n      })\n    }\n  }\n  // помещаем курсор поверх всех элементов\n  if ( moveCursorsToFront && existing_coursor){\n    canvas.bringToFront(existing_coursor)\n    moveCursorsToFront = false;\n  }\n  canvas.renderAll();\n}                                                     // Получение координат курсора\n\n\n\nfunction handleScale (delta){\n    if (delta<0)   {\n        if(currentValueZoom<=MAX_ZOOM_OUT)    {\n            return;\n        }\n        else        {\n            currentValueZoom = (parseFloat(currentValueZoom)-SCALE_STEP).toFixed(2);\n        }\n    }\n    else    {\n        if(currentValueZoom>=MAX_ZOOM_IN)        {\n            return;\n        }\n        else        {\n            currentValueZoom = (parseFloat(currentValueZoom)+SCALE_STEP).toFixed(2);\n        }\n    }\n}\n\n//const canvas = new fabric.Canvas(document.getElementById(\"canvasId\"),{ renderOnAddRemove: false });\nconst as = document.querySelector(\".scale__value\");\nwindow.canvas = canvas;\n\nlet isCursorMove = false;\n\nfunction get_board_id() {\n  return document.getElementById(\"board_id\").attributes[\"board\"].value;\n}\n\nlet isDown = false;\n\nconst buttonCursorMove = document.querySelector('#moving_our_board'); \n\nconst menu_logo = document.querySelector(\".top-panel__logo\");\nmenu_logo.addEventListener('click', e=> e.currentTarget.classList.toggle('active') );\n\nconst menu_grid = document.querySelector(\".grid-panel\");\nmenu_grid.addEventListener('click', e=> e.currentTarget.classList.toggle('active') );\n\n\nfunction chunk (arr, len) {\n\n  var chunks = [],\n      i = 0,\n      n = arr.length;\n\n  while (i < n) {\n    chunks.push(arr.slice(i, i += len));\n  }\n\n  return chunks;\n}\n\n\nvar elt = document.getElementById('desmos_block');\nvar calculator = Desmos.GraphingCalculator(elt);\ncalculator.setExpression({ id: 'graph1', latex: 'y=x^2' });\n\n\nconst pathUsualGrid = \"./images/grids/usual-grid.svg\";\nconst pathTriangularGrid = \"./images/grids/triangular-grid.svg\";\n\n/**\n * Переопределение функции переключения режимов навигация/редактирование объектов\n * @param {Bool} state_ если задано true то перемещение поля, если false то перемещение объектов\n */\nfabric.Canvas.prototype.toggleDragMode = function (state_=false) {\n  // console.log('toggle');\n  \n  // Remember the previous X and Y coordinates for delta calculations\n  if ( this.lastClientX === undefined) {\n    this.lastClientX = 0\n  }\n  if ( this.lastClientY === undefined) {\n    this.lastClientY = 0\n  }\n  // let lastClientY;\n  // Keep track of the state\n\n  let deltaX;\n  let deltaY;\n  const STATE_IDLE = \"idle\";\n  const STATE_PANNING = \"panning\";\n  let state = STATE_IDLE;\n  \n  // We're entering dragmode\n  if (  state_ ) {\n      this.off('mouse:move');\n      // Discard any active object\n      this.discardActiveObject();\n      // Set the cursor to 'move'\n      this.defaultCursor = \"move\";\n      // Loop over all objects and disable events / selectable. We remember its value in a temp variable stored on each object\n      this.forEachObject(function (object) {\n          object.prevEvented = object.evented;\n          object.prevSelectable = object.selectable;\n          object.evented = false;\n          object.selectable = false;\n      });\n      // Remove selection ability on the canvas\n      this.selection = false;\n      // // When MouseUp fires, we set the state to idle\n      this.on(\"mouse:up\", function (e) {\n          state = STATE_IDLE;\n          // console.log(\"mouse:up 1\");\n      });\n      // // When MouseDown fires, we set the state to panning\n      this.on(\"mouse:down\", (e) => {\n          state = STATE_PANNING;\n          if ( e.e.changedTouches!==undefined && e.e.changedTouches.length==1 ){ \n            let lt_ = e.e.changedTouches[0];\n            this.lastClientX = lt_.clientX;\n            this.lastClientY = lt_.clientY;\n          }else{\n            this.lastClientX = e.e.clientX;\n            this.lastClientY = e.e.clientY;\n          }\n\n      });\n      // When the mouse moves, and we're panning (mouse down), we continue\n      this.on(\"mouse:move\", (e) => {\n          if (state === STATE_PANNING && e && e.e) {\n              let x_,y_;\n              if ( e.e.changedTouches!==undefined && e.e.changedTouches.length>0 ){ \n                // if (e.e.changedTouches.length){\n                  let lt_ = e.e.changedTouches[0];\n                  x_ = lt_.clientX;\n                  y_ = lt_.clientY;\n                // }else{\n                //   x_ = (e.e.changedTouches[0].clientX+e.e.changedTouches[1].clientX)/2;\n                //   y_ = (e.e.changedTouches[0].clientY+e.e.changedTouches[1].clientY)/2;\n                // }\n              }else{\n                x_ = e.e.clientX;\n                y_ = e.e.clientY;\n              }\n              if (this.lastClientX) {\n                  deltaX = x_ - this.lastClientX; // смещение по оси X\n                                                      // (если вниз передвигаемся, то\n                                                      // это значение уменьшается иначе увеличивается)\n              }\n              if (this.lastClientY) {\n                  deltaY = y_ - this.lastClientY; // смещение по оси Y\n                                                      // (если влево передвигаемся, то\n                                                      // это значение увеличивается иначе уменьшается)\n              }\n              // Update the last X and Y values\n              this.lastClientX=x_;\n              this.lastClientY=y_;\n              let delta = new fabric.Point(deltaX, deltaY);\n              //this.relativePan(delta);\n              //canvasbg.relativePan(delta);\n              fabric.util.animate({\n                duration: 1,\n                onChange: function() {\n                    canvas.relativePan(delta)\n                    canvasbg.relativePan(delta);\n                },\n                onComplete: function() {\n                    e.e.preventDefault();\n                    e.e.stopPropagation();\n                }\n            });\n\n          }\n          handleMouseMovement(e)\n      });\n      // this.on(\"mouse:move\", (event) => handleMouseMovement(event))\n  } else {\n      // When we exit dragmode, we restore the previous values on all objects\n      this.forEachObject(function (object) {\n          object.evented = object.prevEvented !== undefined ? object.prevEvented : object.evented;\n          object.selectable = object.prevSelectable !== undefined ? object.prevSelectable : object.selectable;\n      });\n      // Reset the cursor\n      this.defaultCursor = \"default\";\n      // Remove the event listeners\n      // console.log(\"off all\");\n      this.off(\"mouse:up\");\n      this.off(\"mouse:down\");\n      this.off(\"mouse:move\");\n      this.on(\"mouse:move\", (event) => handleMouseMovement(event))\n      // Restore selection ability on the canvas\n      this.selection = true;\n  }\n};\n\n\n\nconst freeDrawingButton          = document.querySelector('#free_drawing_button');\n      freeDrawingButton.onclick  = enableFreeDrawing;\nconst freeEraseingButton         = document.querySelector('#free_erasing_button');\n      freeEraseingButton.onclick = enableEraser;\nconst selectionButton            = document.querySelector('#selection_button');\n      selectionButton.onclick    = enableSelection;\nconst BladeButton                = document.querySelector('#blade_button');\n      BladeButton.onclick        = bladeButtonClick;\nconst LassoButton                = document.querySelector('#lasso_button');\n      LassoButton.onclick        = lassoButtonClick;\nconst SliderButton               = document.querySelector('#slider_button');\n      SliderButton.onclick       = sliderButtonClick;\n\n\nconst downloadImage = () =>  {\n   const ext = \"png\";\n  //  canvas._objects.forEach( (obj, index)=>{\n  //   if ( obj.src!==undefined ){\n  //     // obj._element.currentSrc = \"/download/\"+encodeURIComponent(obj.src)\n  //     // obj._element.src = \"/download/\"+encodeURIComponent(obj.src)\n  //     // obj._element.crossOrigin = 'anonymous'\n  //     // obj.src = \"/download/\"+encodeURIComponent(obj.src)\n  //   }\n  //  } )\n  //  canvas._objects.forEach( (obj, index)=>{\n  //   console.log(index, obj._element);\n  //   if ( obj.src!==undefined ){\n  //     console.log(obj._element.currentSrc);\n  //   }\n  //  })\n   const base64 = canvas.toDataURL({\n     format: ext,\n     enableRetinaScaling: true\n   });\n   const link = document.createElement(\"a\");\n   link.href = base64;\n   link.download = `eraser_example.${ext}`;\n   link.click();\n };\n\n\nconst circleDrawingButton = document.querySelector('#circle_drawing_empty_button');\ncircleDrawingButton.addEventListener(\"click\",(e) =>  drawcle(\"empty\"));\n\nconst circleDrawingButtonDotted = document.querySelector('#circle_with_stroke_line_button');\ncircleDrawingButtonDotted.addEventListener(\"click\",(e) =>  drawcle(\"empty_with_stroke_line\"));\n\nconst circleDrawingButtonFilled = document.querySelector('#circle_filled');\ncircleDrawingButtonFilled.addEventListener(\"click\",(e) =>  drawcle(\"filled\"));\n\nconst rectangleDrawingButton = document.querySelector('#rectangle_drawing_empty_button');\nrectangleDrawingButton.addEventListener(\"click\",(e) =>  drawrec(\"empty\"));\n\nconst rectangleDrawingButtonDotted = document.querySelector('#rectangle_with_stroke_line_button');\nrectangleDrawingButtonDotted.addEventListener(\"click\",(e) => drawrec(\"empty_with_stroke_line\"));\n\nconst rectangleDrawingButtonFilled = document.querySelector('#rectangle_filled');\nrectangleDrawingButtonFilled.addEventListener(\"click\",(e) =>  drawrec(\"filled\"));\n\nconst lineDrawingButton = document.querySelector('#line_drawing_button');\nlineDrawingButton.addEventListener(\"click\",(e) => drawLine('trivial'));\n\nconst lineDrawingButtonDOtted = document.querySelector('#line_drawing_button_dotted');\nlineDrawingButtonDOtted.addEventListener(\"click\",(e) => drawLine('dotted'));\n\nconst lineDrawingButtonArrow = document.querySelector('#line_drawing_button_arrow');\nlineDrawingButtonArrow.addEventListener(\"click\",(e) => drawLine('arrow'));\n\nconst lineDrawingButtonArrowTwo = document.querySelector('#line_drawing_button_arrowtwo');\nlineDrawingButtonArrowTwo.addEventListener(\"click\",(e) => drawLine('arrowtwo'));\n\nconst waitingOverlayBlock = document.querySelector('#waiting-overlay');\n// попап с подтверждением пользователя\nconst notifyPopup = document.querySelector('#accept_user_notify')\n\n/**\n * Показываем оверлей ожидания\n */\nfunction showWaitingOverlay(){\n  waitingOverlay = true;\n  waitingOverlayBlock.classList.remove('is-hidden')\n}\n\n/**\n * Скрываем оверлей ожидания\n */\nfunction hideWaitingOverlay(){\n  waitingOverlay = false;\n  waitingOverlayBlock.classList.add('is-hidden')\n}\n\n/**\n * Проверяем залогинен ли пользователь\n */\nfunction checkLoggedIn(){\n  fetch(serverHostDebug+'/check_user_id/').then( data=>data.json()).then(e=>{\n    // если пользователь не залогинен - перенаправляем на страницу логина\n    if ( e===undefined || !e || e.user==false || e.user=='False' ){\n      window.location.href=serverHostDebug+\"/auth?parametr_enter=email\";\n      return;\n    }\n    // сохраняем пользователя через сокеты\n    socket.emit(\"user:user_id\",{user:e.user, board:board_id, socket_id: socket.id});\n    // отправляем запрос на регистрацию на доске\n    socket.emit(\"access:request\", {user:e.user, board:board_id});\n    // показываем оверлей ожидания\n    showWaitingOverlay()\n    \n  });\n}\n\nfunction checkLoggedInCookie(){\n  let user_id = Cookies.get('user_id');\n\n  // если пользователь не залогинен - перенаправляем на страницу логина\n  if ( user_id===undefined || !user_id || user_id==false||user_id==='-1' ){\n    window.location.href=serverHostDebug+\"/auth?parametr_enter=email\";\n    return;\n  }\n  // сохраняем пользователя через сокеты\n  socket.emit(\"user:user_id\",{user:user_id, board:board_id, socket_id: socket.id});\n  // отправляем запрос на регистрацию на доске\n  socket.emit(\"access:request\", {user:user_id, board:board_id});\n  // показываем оверлей ожидания\n  showWaitingOverlay()\n}\n\n/**\n * Разрешаю пользователю войти в доску\n * @param {*} e \n */\nfunction acceptAccess(e){\n  let creator_id = Cookies.get('user_id');\n  socket.emit(\"creator:response\",{ board_id:e.currentTarget.dataset.board, user_id:e.currentTarget.dataset.user, creator_id: creator_id, role:'student' });\n  notifyPopup.classList.add('is-hidden');\n}\n\n/**\n * Запрещаем доступ\n * @param {*} e \n */\nfunction declineAccess(e){\n  let creator_id = Cookies.get('user_id');\n  socket.emit(\"creator:decline\",{ board_id:e.currentTarget.dataset.board, user_id:e.currentTarget.dataset.user, creator_id:creator_id });\n  notifyPopup.classList.add('is-hidden');\n  // \n}\n\n/**\n * задаем параметры объекта fabricjs\n * @param {*} obj_ объект fabricjs\n * @returns object of fabricjs\n */\nfunction object_set_id(obj_){\n  let object = obj_\n  object.set('id',Date.now().toString(36) + Math.random().toString(36).substring(2));\n  object.toJSON = (function(toJSON){\n    return function(){\n      return fabric.util.object.extend(toJSON.call(this),{\"id\":this.id})\n    }\n  })(object.toJSON)\n  return object\n}\n\n/**\n * корректируем путь объекта из точек\n * @param {*} obj_ объект fabricjs\n */\nfunction object_fit_apth(obj_){\n  let object = obj_;\n\n  if(object.path) {\n    let massiv_of_points = object.path.map(function(item) {\n      if(item[0]=='M'||item[0]=='L')  {\n        return [item[1],item[2]];\n      } else{\n        return [item[1],item[2]];\n      }            \n    })\n    const error = 30;\n    let bezierCurves = fitCurve(massiv_of_points, error);\n    if( bezierCurves===undefined || bezierCurves[0]===undefined || !bezierCurves[0]) {\n\n    }\n    let bezierProcessedPath = [\n      ['M',...bezierCurves[0][0]]\n    ];\n\n    for (let i = 0; i < bezierCurves.length; i++) {\n        bezierProcessedPath.push(['C',...bezierCurves[i][1],...bezierCurves[i][2],...bezierCurves[i][3]]);\n    }\n\n    object.path = bezierProcessedPath.map(function(item){\n      if(item.length==3){\n        return [item[0],Math.round(item[1]),Math.round(item[2])];\n      }\n      if (item.length==7) {\n        return [item[0],Math.round(item[1]),Math.round(item[2]),Math.round(item[3]),Math.round(item[4]),Math.round(item[5]),Math.round(item[6])];\n      }\n    });\n\n    \n    objectAddInteractive(object);\n\n  }\n  return object;\n}\n\n/**\n *\n * Событие подключения к сокету\n *\n */\nsocket.on('connect', function()\n{\n  canvasbg.isDrawingMode = false;\n  // checkLoggedIn();\n  checkLoggedInCookie();\n  // получаем ответ на наш запрос - можно на доску заходить или нет?\n  socket.on('access:response', function(data){\n    if ( data.role!='' && data.role!='waiting' ){\n      hideWaitingOverlay()\n      socket.emit(\"board:board_id\",board_id);\n    }      \n  });\n\n  // очищаем доску по сигналу\n  socket.on(\"canvas:clear\", (e)=>clearBoard(false) );\n\n  // запрос администратора на одобрение\n  socket.on('creator:request', (e)=>{\n    // { board_id:e.board, user_id:e.user }\n    notifyPopup.classList.remove('is-hidden');\n    let userid = \"\";\n    if ( e.username && e.username!='' ){\n      userid += String(e.username)\n    }\n    if ( e.email && e.email!='' ){\n      userid += \" (\"+String(e.email)+\")\"\n    }\n    notifyPopup.querySelector('#user_name').textContent=userid\n    notifyPopup.querySelector('#button-accept').dataset.user=e.user_id\n    notifyPopup.querySelector('#button-accept').dataset.board=e.board_id\n    notifyPopup.querySelector('#button-decline').dataset.user=e.user_id\n    notifyPopup.querySelector('#button-decline').dataset.board=e.board_id\n    notifyPopup.querySelector('#button-accept').addEventListener('click',acceptAccess, { once: true })\n    notifyPopup.querySelector('#button-decline').addEventListener('click',declineAccess, { once: true })\n  });\n\n  socket.on('mouse:up', function(pointer) {\n    let brushName = `freeDrawingBrush_${pointer.id}`;\n    if ( canvasbg[brushName]!==undefined ){\n      canvasbg[brushName].onMouseUp({e:{}});\n\n    }\n    canvasbg.isDrawingMode = false\n  });\n\n  socket.on('mouse:down', function(pointer)    {\n    canvasbg.isDrawingMode = true;\n\n    let brushName = `freeDrawingBrush_${pointer.id}`;\n    if ( canvasbg[brushName]===undefined ){\n      canvasbg[brushName] = new fabric.PencilBrush(canvasbg)\n    }\n    // canvasbg[brushName].width = pointer.width;\n    // canvasbg[brushName].color = pointer.color;\n    if (canvasbg[brushName].btype ===undefined || canvasbg[brushName].btype!='eraser' ){\n      if (pointer.type!==undefined && pointer.type=='eraser'){\n        canvas.isDrawingMode = true\n        canvas[brushName] = new fabric.EraserBrush(canvas)\n        canvas[brushName].btype = 'eraser'\n      }\n    }else{\n      if (pointer.type!==undefined && pointer.type=='brush'){\n        canvasbg[brushName] = new fabric.PencilBrush(canvasbg)\n        canvasbg[brushName].btype = 'brush'\n      }\n    }\n\n    if (pointer.type!==undefined && pointer.type=='brush'){\n      canvasbg[brushName] = new fabric.PencilBrush(canvasbg)\n      canvasbg[brushName].btype = 'brush';\n      canvas[brushName] = new fabric.PencilBrush(canvas)\n      canvas[brushName].btype = 'brush'\n      canvasbg[brushName].color = pointer.color;\n      canvasbg[brushName].width = pointer.width;\n    }\n    if (pointer.type!==undefined && pointer.type=='lasso'){\n      canvasbg[brushName] = new fabric.LassoBrush(canvasbg);\n      canvasbg[brushName].color = pointer.color;\n      canvasbg[brushName].btype = 'lasso'\n      canvasbg.isDrawingMode = true;\n      canvasbg[brushName].width = 0;\n    }\n\n\n    canvasbg[brushName].onMouseDown(pointer.pointer,{e:{}});\n  });\n\n  socket.on('mouse:draw', function(e)  {\n    let brushName = `freeDrawingBrush_${e.id}`;\n    if ( canvasbg[brushName]!==undefined && canvasbg.isDrawingMode ){\n      // canvasbg.freeDrawingBrush.color = e.color;\n      // canvasbg.freeDrawingBrush.width = e.width;\n      canvasbg[brushName].onMouseMove(e.pointer,{e:{}});\n    }\n  });\n\n  socket.on('color:change', function(colour_taken) {\n    if ( canvasbg.freeDrawingBrush!==undefined ){\n      canvasbg.freeDrawingBrush.color = colour_taken;\n    }        \n  });\n\n  socket.on('width:change', function(width_taken)\n  {\n    // console.log(width_taken);\n    if ( canvasbg.freeDrawingBrush!==undefined ){\n      canvasbg.freeDrawingBrush.width = width_taken;\n    }\n  });\n  \n\n  // let circle ;\n  socket.on('circle:edit', function(circle_taken)\n  {\n    let circle = canvas._objects.find( item => item.id==circle_taken.id )\n    if ( circle ){\n      circle.set({\n        radius: circle_taken.radius\n      });\n      canvas.renderAll();\n    }\n  });\n  \n  socket.on('circle:add', function(circle_taken)\n  {\n    let pos_ = { \"left\": circle_taken.left, \"top\": circle_taken.top}\n    // без этого фокуса не работает рисование за границей видимости на партнерской доске\n    circle_taken.left = 1;\n    circle_taken.top = 1;\n    enliveObjects([circle_taken]);\n    let circle = canvas._objects.find( item => item.id==circle_taken.id )\n    circle.set({\n      left: pos_.left,\n      top: pos_.top\n    });\n    canvas.renderAll();\n  });\n\n  socket.on('rect:edit', function(rect_taken)   {\n    let rect = canvas._objects.find( item => item.id==rect_taken.id )\n    if ( rect ){\n      rect.set({\n        top: rect_taken.top,\n        left: rect_taken.left,\n        width: rect_taken.width,\n        height: rect_taken.height\n      });\n      canvas.renderAll();\n    }\n  });\n\n  socket.on('rect:add', function(rect_taken)\n  {\n    let pos_ = { \"left\": rect_taken.left, \"top\": rect_taken.top}\n    // без этого фокуса не работает рисование за границей видимости на партнерской доске\n    rect_taken.left = 1;\n    rect_taken.top = 1;\n    enliveObjects([rect_taken]);\n    let rect = canvas._objects.find( item => item.id==rect_taken.id )\n    rect.set({\n      left: pos_.left,\n      top: pos_.top\n    });\n    canvas.renderAll();\n  });\n\n  // slider:add\n\n  socket.on('slider:add', function(obj_)  {\n    let slider_taken = obj_.slider;\n    let pos_ = { \"left\": slider_taken.left, \"top\": slider_taken.top}\n    // без этого фокуса не работает рисование за границей видимости на партнерской доске\n    slider_taken.left = 1;\n    slider_taken.top = 1;\n    enliveObjects([slider_taken], () => {\n      let slider = canvas.getObjects().find( item => item.id==slider_taken.id );\n      if ( slider ){\n        slider.set({\n          left: pos_.left,\n          top: pos_.top\n        });\n      }\n      canvas.renderAll();\n    });    \n  });\n\n  let line ;\n\n  socket.on('line:edit', function(line_taken)\n  {\n    line.set({\n      x1: line_taken.x1,\n      y1: line_taken.y1,\n      x2: line_taken.x2,\n      y2: line_taken.y2\n    });\n    canvas.renderAll();\n  });\n\n  \n  socket.on('line:add', function(line_taken) {\n    // console.log(line_taken);\n    if ( line_taken.line_type == \"arrow\" ){\n      line = new fabric.Arrow(line_taken.points, {\n        id: line_taken.id,\n        strokeWidth: parseInt(line_taken.width),//drawing_figure_width.value,\n        fill: line_taken.fill,//'#07ff11a3',\n        stroke: line_taken.stroke,//hexToRgbA(drawing_color_fill.value, drawing_figure_opacity.value),\n        strokeDashArray: line_taken.strokeDashArray,\n        ///stroke: '#07ff11a3',\n        originX: \"center\",\n        originY: \"center\",\n        selectable: false,\n        objectCaching: false,\n      });\n\n    }else if ( line_taken.line_type == \"arrowtwo\" ){\n      line = new fabric.ArrowTwo(line_taken.points, {\n        id: line_taken.id,\n        strokeWidth: parseInt(line_taken.width),//drawing_figure_width.value,\n        fill: line_taken.fill,//'#07ff11a3',\n        stroke: line_taken.stroke,//hexToRgbA(drawing_color_fill.value, drawing_figure_opacity.value),\n        strokeDashArray: line_taken.strokeDashArray,\n        ///stroke: '#07ff11a3',\n        originX: \"center\",\n        originY: \"center\",\n        selectable: false,\n        objectCaching: false,\n      });\n    }else{\n      \n      line = new fabric.Line(line_taken.points, {\n        id: line_taken.id,\n        strokeWidth: parseInt(line_taken.width),\n        fill: line_taken.fill,//'#07ff11a3',\n        stroke: line_taken.stroke,//'#07ff11a3',\n        originX: 'center',\n        originY: 'center',\n        strokeDashArray: line_taken.strokeDashArray,\n        selectable: false,\n        objectCaching: false\n      });\n    }\n      //line = new fabric.Line(line_taken)\n      canvas.add(line)\n      //'canvas.freeDrawingBrush.width = width_taken'\n  });\n\n  /**\n    * добавляем произвольный штрих\n    * @data {\"board_id\": board_id, \"object\": options }\n    */\n  socket.on(\"path:created\", (data)=>{\n    let compare_ = {...data.object.path};\n    canvas.isWaitingPath = compare_;\n  } );\n\n  socket.on('picture:add', function(img_taken)  {\n    try{\n        canvas.loadFromJSON(img_taken);\n    }catch (e){\n      error.log(e)\n    }    \n  });\n\n  socket.on('image:add', async function(img_taken)    {\n    // let loaded = await window.preloadImage(img_taken.src, true, img_taken.id_of)\n    // if (loaded !== true) {\n      window.insertImageOnBoard(img_taken.src, true, img_taken.id_of)\n    // }\n  });\n\n  socket.on( \"send:task\", async function(image_url){\n    // let loaded = await window.preloadImage(image_url,true)\n    // if (loaded !== true) {\n      window.insertImageOnBoard(image_url,true);\n      socket.emit(\"canvas_save_to_json\", {\"board_id\": board_id, \"canvas\": serialize_canvas(canvas)});\n    // }\n  } )\n\n  //////\n\n  socket.on('take_data_from_json_file',function(data)\n  {\n    if(!data || data.constructor !== Object || Object.keys(data).length === 0)\n    {\n      return false;\n    }\n    else\n    {\n      let chunks = chunk(data?.canvas,30);\n      let chunk_index = 0;\n      canvas.renderOnAddRemove=false;\n      let init_interval = setInterval(function(){\n          let chunk = chunks[chunk_index];\n          if(!chunk){\n            clearInterval(init_interval)\n            canvas.renderOnAddRemove=true;\n            return false;\n          }\n          chunk.forEach((object,id)=>{\n            chunk[id]=deserialize(object);\n            // console.log(chunk[id]);\n          });\n          enliveObjects(chunk);\n          canvas.renderAll();\n          chunk_index++;\n      },150)\n\n      // socket.emit(\"canvas_save_to_json\", {\"board_id\": board_id, \"canvas\": serialize_canvas(canvas)});\n      //canvas.loadFromJSON(data);\n    }\n\n  })\n\n\n  // { \"object\":obj_, \"id\":obj_.id, \"color\":color.rgbaString}\n  socket.on('color:changed', function(data)    {\n    let t = canvas._objects.find( item => item.id==data.id )\n    if ( t ){\n      t.changedColour(data.color)\n    }\n  });\n\n  socket.on('width:changed', function(data)    {\n    let t = canvas._objects.find( item => item.id==data.id )\n    if ( t ){\n      t.changedWidth(data.width)\n    }\n  });\n\n  canvas.on('object:modified', e =>    {\n    if(e.action ==\"drag\" && e.target._objects){\n      /*\n      e.target._objects.forEach(object => {\n        object.top  = e.transform.target.top;\n        object.left = e.transform.target.left;\n\n      })*/\n      canvas.discardActiveObject().renderAll()\n    }\n    socket.emit(\"canvas_save_to_json\", {\"board_id\": board_id, \"canvas\": serialize_canvas(canvas)});\n    send_part_of_data(e);\n\n    // send_part_events.push(e);\n  });\n\n\n  canvas.on('object:added',e => {\n    let object = e.target;\n    moveCursorsToFront = true;\n    if ( object.formula!==undefined ){\n      return;\n    }\n    if(!object.id)    {\n      object = object_set_id(object)\n      object = object_fit_apth(object)\n      if(!object.socket_id) {\n        socket.emit(\"object:added\", {\"board_id\": board_id, \"object\": serialize_object(object)});\n        socket.emit(\"canvas_save_to_json\", {\"board_id\": board_id, \"canvas\": serialize_canvas(canvas)});\n      }\n    }\n  });\n\n  canvas.on('object:moving',e =>\n  {\n    socket.emit(\"canvas_save_to_json\", {\"board_id\": board_id, \"canvas\": serialize_canvas(canvas)});\n\n    send_part_of_data(e);\n      // send_part_events.push(e);\n  });\n  canvas.on('moving',e =>\n  {\n      // send_part_events.push(e);\n  });\n  canvas.on('dragenter',e =>\n  {\n    console.log('dragenter');\n      // send_part_events.push(e);\n  });\n\n\n  socket.on('object:moving', e =>\n  {\n    recive_part_of_data(e);\n      // recive_part_events.push(e);\n  });\n\n  socket.on('figure_delete', e => {\n    e.forEach(function(id){\n      canvas._objects.forEach(function(object,index) {\n        // console.log(object.id,id, object.id==id);\n        if(object.id==id) {\n          if ( object.type=='slider' ){\n            object.destroy();\n            // временный фикс, потому что не удаляется через сокеты\n            // скорее всего из-за того, что создается даважды, надо отловить эту штуку\n            canvas.remove(object);\n          }\n          canvas.remove(object);\n        }\n      })\n    })\n    canvas.discardActiveObject();\n    canvas.requestRenderAll();\n  });\n\n  socket.on('figure_copied', e =>\n  {\n      // canvas.sendToBack(cursorUser);\n      canvas.add(new fabric.Object(e));\n      canvas.renderAll();\n      //canvas.loadFromJSON(e);\n  });\n  \n\n  canvas.on('object:scaling',e =>\n  {\n    //socket.emit(\"canvas_save_to_json\", {\"board_id\": board_id, \"canvas\": canvas.toJSON(['id'])});\n    socket.emit(\"canvas_save_to_json\", {\"board_id\": board_id, \"canvas\": serialize_canvas(canvas)});\n    send_part_of_data(e);\n      // send_part_events.push(e);\n  });\n\n\n  socket.on('object:scaling', e =>\n  {\n      recive_part_of_data(e);\n      // recive_part_events.push(e);\n  });\n\n  canvas.on('object:rotating',e =>\n  {\n    socket.emit(\"canvas_save_to_json\", {\"board_id\": board_id, \"canvas\": serialize_canvas(canvas)});\n    send_part_of_data(e);\n      // send_part_events.push(e);\n  });\n\n\n  socket.on('object:rotating', e =>\n  {\n      recive_part_of_data(e);\n      //canvas.loadFromJSON(e);\n      // recive_part_events.push(e);\n  });\n\n  socket.on('text:added', e => {\n    const text = new fabric.IText(e.object.text,e.object);\n    canvas.add(text);\n    canvas.renderAll();\n  });\n\n  /**\n    * ловим изменения текста\n    */\n  socket.on('text:edited', e => {\n    let t = canvas._objects.find( item => item.id==e.id )\n    if ( t ){\n      t.set({...e.object});\n      canvas.renderAll();\n    }\n  });\n\n\n  socket.on('formula:added', e => {\n    window.addFormula( e.formula, e.object.id, e.object, false )\n  });\n\n  /**\n    * ловим изменения текста\n    */\n  socket.on('formula:edited', e => {\n    editFormula( e.formula, e.object.id )\n  });\n\n  socket.on('object:modified', e =>\n  {\n    recive_part_of_data(e);\n  });\n\n  /**\n    * Эмитим событие когда закончили рисовать произвольный путь\n    * прогблема в том, что на остальных досках во время рисования объект еще не создан, а когда\n    * рисование завершено, то объект создается под своим айди на каждой доске. Поэтому редактирование и перемещение\n    * на других досках не работает. Надо передать готовый объект и на досках пересвоить айди\n    */\n  canvas.on(\"path:created\", function(options) {\n    // console.log(\"path created\", options);\n    if ( canvas.isDrawingMode ){\n      socket.emit(\"path:created\", {\"board_id\": board_id, \"object\": options });\n      return;\n    }\n    if ( canvas.isWaitingPath!==undefined && canvas.isWaitingPath!=false ){\n      if ( compare_path(options.path,canvas.isWaitingPath) ){\n        options.path.id = canvas.isWaitingPath.id;\n      }\n      canvas.isWaitingPath = false\n      // objectAddInteractive(options);\n    }\n    \n  });\n  canvasbg.on(\"path:created\",(options)=>{\n    if ( canvas.isWaitingPath!==undefined && canvas.isWaitingPath!=false ){\n      if ( compare_path(options.path,canvas.isWaitingPath) ){\n        canvasbg.remove(options.path)\n        options.path.id = canvas.isWaitingPath.id;\n        canvas.add(options.path)\n        //canvas.add(options.path)\n      }\n      canvas.isWaitingPath = false\n    }\n  });\n  canvasbg.on(\"object:added\", (e)=>{\n    let object = e.target;\n    if(!object.id) {\n      object = object_set_id(object)\n      object = object_fit_apth(object)\n    }\n  });\n  \n});\n\n/**\n * Добавляем интерактивности объекту \n * делаем изменение толщины и цвета\n * @param {*} object \n */\nfunction objectAddInteractive(object){\n  let fn_ = (color)=>{return};\n  if ( ['rect','circle'].indexOf(object.type)!==-1  ){\n    fn_ = (color)=>{\n      object.objectCaching = false;\n      object.fill = color;\n      canvas.renderAll();\n      // object.objectCaching = true;\n    }\n  }else if (['path','Arrow', 'ArrowTwo', 'line' ].indexOf(object.type)!==-1 ){\n    fn_ = (color)=>{\n      object.objectCaching = false;\n      if ( object.fill ){\n        object.fill = color;  \n      }\n      object.stroke = color;\n      canvas.renderAll();\n      // object.objectCaching = true;\n    }\n  }\n  object.changedColour = fn_;\n  object.changedWidth = function(width){\n    object.objectCaching = false;\n    // canvas.freeDrawingBrush.width = parseInt(drawingLineWidthEl.value, 10);\n    this.strokeWidth = parseInt(width);\n    canvas.renderAll();\n  }\n}\n\n\nfunction enableFreeDrawing(){\n  let array_of_points = [];\n  removeEvents();\n  canvas.freeDrawingBrush       = new fabric.PencilBrush(canvas);\n  canvasbg.freeDrawingBrush     = new fabric.PencilBrush(canvasbg);\n  \n  canvas.freeDrawingBrush.btype = \"brush\"\n  \n\n  let isDrawing = false;\n  let enableDrawingMode = true;\n  // canvas._onMouseMoveInDrawingMode = function(e) {\n  //   var pointer = canvas.getPointer(e);\n  //   if (!isDrawing) {\n  //     console.log('enable original mouse move event only one')\n  //     isDrawing = true;\n  //     canvas.freeDrawingBrush.onMouseDown(pointer,{e:{},pointer:pointer});\n  //   }\n  //   canvas.freeDrawingBrush.onMouseMove(pointer,{e:{},pointer:pointer});\n  //   canvas.setCursor(canvas.freeDrawingCursor);\n  //   canvas._handleEvent(e, 'move');\n  //   console.log(e);\n  // }\n  \n  // canvas._onMouseMoveInDrawingMode = function (e) {\n  //   var pointer = canvas.getPointer(e);\n  //   // pointer.x = 100;\n  //   console.log({x:pointer.x, y:pointer.y}, isDrawing, canvas.remoteDrawing );\n  //   if ( isDrawing ){\n      \n  //     canvas.freeDrawingBrush.onMouseMove(pointer,{e:{}});\n  //     canvas.remoteDrawingBrush.onMouseMove({x:pointer.x-50, y:pointer.y},{e:{}});\n  //   }\n  // }\n\n\n    /**\n     * @private\n     * @param {Event} e Event object fired on mousedown\n     */\n    // canvas._onMouseDownInDrawingMode = function(e) {\n    //   this._isCurrentlyDrawing = true;\n    //   if (this.getActiveObject()) {\n    //     this.discardActiveObject(e).requestRenderAll();\n    //   }\n      \n    //   // this.freeDrawingBrush.onMouseDown(pointer, { e: e, pointer: pointer });\n    //   canvas.remoteDrawingBrush = new fabric['PencilBrush'](canvas);\n    //   canvas.remoteDrawingBrush.color = 'green';\n    //   canvas.remoteDrawingBrush.width = 5;\n    //   canvas.remoteDrawingBrush.needsFullRender = ()=>true;\n    //   canvas.remoteDrawingBrush._setBrushStyles(canvas.contextTop)\n    //   canvas.remoteDrawingBrush._captureDrawingPath({x:pointer.x-50, y:pointer.y});\n    //   canvas.remoteDrawingBrush._render();\n      \n    //   // this.remoteDrawingBrush.onMouseDown({x:pointer.x-50, y:pointer.y}, { e: e, pointer: {x:pointer.x-50, y:pointer.y} });\n    //   // this._handleEvent(e, 'down');\n    // },\n\n    /**\n     * @private\n     * @param {Event} e Event object fired on mousemove\n     */\n    // canvas._onMouseMoveInDrawingMode = function(e) {\n    //   if (this._isCurrentlyDrawing) {\n    //     var pointer = this.getPointer(e);\n    //     // console.log();\n    //     this.freeDrawingBrush.onMouseMove(pointer, { e: e, pointer: pointer });\n    //     // canvas.freeDrawingBrush.onMouseMove(pointer,{e:{}});\n    //     this.remoteDrawingBrush.onMouseMove({x:pointer.x-50, y:pointer.y},{e:e, pointer: {x:pointer.x-50, y:pointer.y}});\n    //   }\n    //   this.setCursor(this.freeDrawingCursor);\n    //   this._handleEvent(e, 'move');\n    // },\n\n    /**\n     * @private\n     * @param {Event} e Event object fired on mouseup\n     */\n    // canvas._onMouseUpInDrawingMode = function(e) {\n    //   var pointer = this.getPointer(e);\n    //   this._isCurrentlyDrawing = this.freeDrawingBrush.onMouseUp({ e: e, pointer: pointer });\n    //   this.remoteDrawingBrush.onMouseUp({ e: e, pointer: {x:pointer.x-50, y:pointer.y} });\n    //   this._handleEvent(e, 'up');\n    // },\n\n  canvas.isDrawingMode          = true;\n  canvas.on('mouse:down', e => {\n    // console.log('mouse:down',e);\n    \n    isDrawing = true;\n    const pointer = canvas.getPointer(e);    \n    // canvas.freeDrawingBrush = new fabric['PencilBrush'](canvas);\n    canvas.freeDrawingBrush.color = drawingColorEl.style.backgroundColor;\n    canvas.freeDrawingBrush.width = parseInt(drawingLineWidthEl.value, 10);\n    // canvas.freeDrawingBrush.needsFullRender = ()=>true;\n    // canvas.freeDrawingBrush._setBrushStyles(canvas.contextTop)\n    // canvas.freeDrawingBrush._captureDrawingPath(pointer);\n    // canvas.freeDrawingBrush._render();\n    canvas.freeDrawingBrush.onMouseDown(pointer,{e:{}});\n    \n    // canvas.remoteDrawingBrush.onMouseDown({x:pointer.x-50, y:pointer.y},{e:{}});\n    socket.emit('mouse:down', {pointer, id:socket.id,width:canvas.freeDrawingBrush.width, color:canvas.freeDrawingBrush.color, type:'brush'});\n  })\n  canvas.on('mouse:up', e => {\n    isDrawing = false;\n    const pointer = canvas.getPointer(e);\n    socket.emit('mouse:up',{pointer, id:socket.id, width:canvas.freeDrawingBrush.width, color:canvas.freeDrawingBrush.color, type:'brush'});\n    //socket.emit(\"canvas_save_to_json\", {\"board_id\": board_id, \"canvas\": serialize_canvas(canvas)});\n  })\n  canvas.on('mouse:move', function (e) {\n    if (isDrawing) {\n      const pointer = canvas.getPointer(e);\n      // canvas.freeDrawingBrush.width=7;\n      canvas.freeDrawingBrush.onMouseMove(pointer,{e:{}});\n      // canvas.remoteDrawingBrush.onMouseMove({x:pointer.x-50, y:pointer.y},{e:{}});\n      socket.emit('mouse:draw',{pointer, id:socket.id,width:canvas.freeDrawingBrush.width, color:canvas.freeDrawingBrush.color, type:'brush'});//canvas.freeDrawingBrush._points); \n    }\n  })\n}\n\n/**\n * Добавляем \n */\nfunction sliderButtonClick(){\n  removeEvents();\n  let slider = new fabric.Slider(canvas);\n  slider.onReady = ()=>{\n    canvas.add(slider);\n    setObjectToCanvasCenter(slider);\n    // slider.alignMenu();\n    canvas.setActiveObject(slider).requestRenderAll(); \n    // отправляем сигнал на сокет\n    socket.emit(\"slider:add\", {\"slider\":slider});\n  }\n  slider.setSocket(socket);\n}\n\n/**\n * Включаем инструмент лассо\n */\nfunction lassoButtonClick(){\n  let isDrawing = false;\n  removeEvents();\n  canvas.freeDrawingBrush = new fabric.LassoBrush(canvas);\n  canvas.freeDrawingBrush.color = drawingColorEl.style.backgroundColor;\n  canvas.isDrawingMode = true;\n\n  canvas.on('mouse:down', e => {\n    isDrawing = true;\n    const pointer = canvas.getPointer(e);\n    socket.emit('mouse:down', {pointer, width:canvas.freeDrawingBrush.width, color:canvas.freeDrawingBrush.color, type:'lasso'});\n  })\n  canvas.on('mouse:up', e => {\n    isDrawing = false;\n    const pointer = canvas.getPointer(e);\n    socket.emit('mouse:up',{pointer, width:canvas.freeDrawingBrush.width, color:canvas.freeDrawingBrush.color, type:'lasso'});\n    socket.emit(\"canvas_save_to_json\", {\"board_id\": board_id, \"canvas\": serialize_canvas(canvas)});\n  })\n  canvas.on('mouse:move', (e)=> {\n    if (isDrawing) {\n      const pointer = canvas.getPointer(e);\n      socket.emit('mouse:draw',{pointer, width:canvas.freeDrawingBrush.width, color:canvas.freeDrawingBrush.color, type:'lasso'});//canvas.freeDrawingBrush._points); \n    }\n  })\n\n}\n\n/**\n * Выбираем ластик\n */\nfunction enableEraser(){\n  removeEvents();\n  canvas.freeDrawingBrush = new fabric.EraserBrush(canvas);\n  canvas.isDrawingMode = true;\n  canvas.freeDrawingBrush.width = parseInt(drawingLineWidthEl.value, 10);\n\n  let isDrawing = false\n\n  canvas.on('mouse:down', e => {\n    isDrawing = true;\n    const pointer = canvas.getPointer(e);\n    socket.emit('mouse:down', {pointer, width:canvas.freeDrawingBrush.width, color:canvas.freeDrawingBrush.color, type:'eraser'});\n  })\n  canvas.on('mouse:up', e => {\n    isDrawing = false;\n    const pointer = canvas.getPointer(e);\n    socket.emit('mouse:up',{pointer, width:canvas.freeDrawingBrush.width, color:canvas.freeDrawingBrush.color, type:'eraser'});\n    socket.emit(\"canvas_save_to_json\", {\"board_id\": board_id, \"canvas\": serialize_canvas(canvas)});\n  })\n  canvas.on('mouse:move', (e)=> {\n    if (isDrawing) {\n      const pointer = canvas.getPointer(e);\n      socket.emit('mouse:draw',{pointer, width:canvas.freeDrawingBrush.width, color:canvas.freeDrawingBrush.color, type:'eraser'});//canvas.freeDrawingBrush._points); \n    }\n  })\n}\n\nfunction enliveObjects(chunk, callback){\n  fabric.util.enlivenObjects(chunk,function(objects)\n  {\n    // сохраняем количество объектов\n    allReceivedObjects = objects.length\n    objects.forEach(function(object) {\n      let obj_exists = false;\n      // console.log(object.type);\n      canvas._objects.every(function(obj_,indx_){\n          if ( obj_.id==object.id ){\n            obj_exists = true;\n            return false\n          }\n          return true;\n      });\n      // если такого объекта еще нет на канвасе, то добавляем\n      if ( obj_exists===false ){\n        \n        if ( object.type=='image'  ){\n          if ( object.src!==undefined && object.src!='' ){\n            window.insertImageOnBoard(object.src, true, object.id, object);\n          }else{\n            if (object.formula!==undefined && object.formula!=''){\n              window.addFormula(object.formula, object.id, object,false)\n            }\n          }\n        } else{\n          \n          if ( object.type==\"slider\" ) {\n            // оживляем слайдер и вешаем на него сокет\n            // console.log(\"socket \");\n            object.setSocket(socket);\n          }\n          objectAddInteractive(object);\n          canvas.add(object);\n          if ( takedFirstData==false ){\n            object.set({ selectable: false })\n          }\n          let res = decreaseRecievedObjects();\n          \n          // вызываем коллбек когда все добавлено и закончили отрисовку\n          if ( res==END_OF_RECIEVE_OBJECTS && typeof(callback)=='function' ){\n            callback();\n          }\n        }\n      }                \n    })\n    \n  });\n}\n\n/**\n * Нажатие на кнопку удаления выделенных фрагментов\n */\nfunction bladeButtonClick(){\n\n  removeEvents();\n  let bladeDown = false;\n  canvas.on('mouse:down', e => {   \n    bladeDown = true;\n  })\n  canvas.on('mouse:up', e => {\n    bladeDown = false;\n  })\n  canvas.on('mouse:move', function (e) {\n    if (bladeDown) {\n      const cursorCoordinate = canvas.getPointer(e);\n      // console.log(canvas._objects);\n      // let points = [pointer.x, pointer.y, pointer.x, pointer.y];\n      let d = [];\n      canvas._objects.forEach(item=>{\n        if (!item){\n          return false\n        }\n        let bound = item.getBoundingRect();\n        // console.log( cursorCoordinate.x , bound.left, bound.left + bound.width ,bound );\n        if ( cursorCoordinate.x > bound.left && cursorCoordinate.x < (bound.left + bound.width) &&\n             cursorCoordinate.y > bound.top && cursorCoordinate.y < (bound.top + bound.height)  ) {\n          d.push(item);\n          // console.log(item);\n          canvas.setActiveObject(item);\n        }\n        // return false\n      });\n      // console.log(d);\n      Delete();\n    }\n  })\n  // Delete();\n\n}\n\nfunction enableSelection() {\n  removeEvents();\n  canvas.toggleDragMode(false);\n  isCursorMove=false;\n  changeObjectSelection(true);\n  canvas.on(\"mouse:down\", (e) => {\n    let d = canvas.getActiveObject();\n  });\n}\n\n\nfunction drawrec(type_of_rectangle) {\n  var rect, isDown, origX, origY;\n  removeEvents();\n  changeObjectSelection(false);\n  colour_inside = 'Black';\n  let stroke_line = 0;\n  \n  if (type_of_rectangle == \"empty\")  {\n    colour_inside = hexToRgbA('#000dff',5);\n    stroke_line   = 0;\n  } else if(type_of_rectangle == \"empty_with_stroke_line\") {\n    colour_inside = hexToRgbA('#000dff',5);\n    stroke_line = 20;\n  }  else if (type_of_rectangle == \"filled\")  {\n    colour_inside = drawingColorEl.style.backgroundColor;\n    stroke_line = 0;\n  }\n\n  canvas.on(\"mouse:down\", function (o) {\n    isDown = true;\n    var pointer = canvas.getPointer(o.e);\n    origX = pointer.x;\n    origY = pointer.y;\n    var pointer = canvas.getPointer(o.e);\n    rect = new fabric.Rect({\n      left: origX,\n      top: origY,\n      originX: \"left\",\n      originY: \"top\",\n      width: pointer.x - origX,\n      height: pointer.y - origY,\n      angle: 0,\n      selectable: false,\n      \n      fill: colour_inside,//hexToRgbA(drawing_color_fill.value, drawing_figure_opacity.value),\n      stroke: 'Black',//drawing_color_border.value,\n      strokeDashArray: [stroke_line, stroke_line],\n      transparentCorners: false,\n      objectCaching: false,\n    });\n    rect.changedColour = function(color){\n      rect.fill = color;\n      // console.log(\"rect\",rect);\n      canvas.renderAll();\n    }\n    rect.changedWidth = function(width){\n      rect.objectCaching = false;\n      // canvas.freeDrawingBrush.width = parseInt(drawingLineWidthEl.value, 10);\n      this.strokeWidth = parseInt(width);\n      canvas.renderAll();\n    }\n    canvas.add(rect);\n    socket.emit(\"rect:add\", rect);\n  });\n\n  //strokeWidth: 2,//drawing_figure_width.value,\n\n\n  canvas.on(\"mouse:move\", function (o) {\n    if (!isDown) return;\n    var pointer = canvas.getPointer(o.e);\n\n    if (origX > pointer.x) {\n      rect.set({\n        left: Math.abs(pointer.x),\n      });\n    }\n    if (origY > pointer.y) {\n      rect.set({\n        top: Math.abs(pointer.y),\n      });\n    }\n\n    rect.set({\n      width: Math.abs(origX - pointer.x),\n    });\n    rect.set({\n      height: Math.abs(origY - pointer.y),\n    });\n\n    socket.emit(\"rect:edit\", rect);\n    canvas.renderAll();\n  });\n\n  canvas.on(\"mouse:up\", function (o) {\n    isDown = false;\n    rect.setCoords();\n    //socket.emit(\"canvas_save_to_json\", canvas.toJSON(['id']));\n    // let board_id = get_board_id();\n    socket.emit(\"canvas_save_to_json\", {\"board_id\": board_id, \"canvas\": serialize_canvas(canvas)});\n    //socket.emit(\"canvas_save_to_json\", {\"board_id\": board_id, \"canvas\": canvas.toJSON(['id'])});\n  });\n}\n\n\nfunction drawcle(type_of_circle) {\n  \n  colour_inside = 'Black';\n  let stroke_line   = 0;\n  if (type_of_circle == \"empty\")\n  {\n        colour_inside = hexToRgbA('#000dff',5);//hexToRgbA(drawing_color_fill.value, drawing_figure_opacity.value),\n        stroke_line   = 0;\n  }\n  else if(type_of_circle == \"empty_with_stroke_line\")\n  {\n    colour_inside = hexToRgbA('#000dff',5);\n    stroke_line = 20;\n  }\n  else if (type_of_circle == \"filled\")\n  {\n    colour_inside = drawingColorEl.style.backgroundColor;\n    stroke_line = 0;\n  }\n\n  var circle, isDown, origX, origY;\n  removeEvents();\n  changeObjectSelection(false);\n  canvas.on(\"mouse:down\", function (o) {\n    isDown = true;\n    var pointer = canvas.getPointer(o.e);\n    origX = pointer.x;\n    origY = pointer.y;\n    circle = new fabric.Circle({\n      left: pointer.x,\n      top: pointer.y,\n      radius: 1,\n      strokeWidth: 2,//drawing_figure_width.value,\n      fill: colour_inside,\n      stroke: 'Black',\n      strokeDashArray: [stroke_line, stroke_line],//drawing_color_border.value,strokeDashArray: [stroke_line, stroke_line],\n      selectable: false,\n      originX: \"center\",\n      originY: \"center\",\n      objectCaching: false,\n    });\n    circle.changedColour = function(color){\n      circle.fill = color;\n      // console.log(\"circle log\");\n      canvas.renderAll();\n    }\n    circle.changedWidth = function(width){\n      circle.objectCaching = false;\n      // canvas.freeDrawingBrush.width = parseInt(drawingLineWidthEl.value, 10);\n      this.strokeWidth = parseInt(width);\n      canvas.renderAll();\n    }\n    canvas.add(circle);\n    socket.emit(\"circle:add\", circle);\n  });\n\n  canvas.on(\"mouse:move\", function (o) {\n    if (!isDown) return;\n    var pointer = canvas.getPointer(o.e);\n    circle.set({\n      radius: Math.abs(origX - pointer.x),\n    });\n    socket.emit(\"circle:edit\", circle);\n    canvas.renderAll();\n  });\n\n  canvas.on(\"mouse:up\", function (o) {\n    isDown = false;\n    circle.setCoords();\n    socket.emit(\"canvas_save_to_json\", {\"board_id\": board_id, \"canvas\": serialize_canvas(canvas)});\n  });\n\n}\n\ncanvas.setBackgroundColor(\n    {\n      source: pathUsualGrid,\n      repeat: \"repeat\",\n      scaleX: 1,\n      scaleY: 1,\n    },\n    canvas.renderAll.bind(canvas)\n);\n\n\nwindow.addEventListener(\"resize\", resizeCanvas, false);\n\nfunction resizeCanvas() {\n  canvas.setHeight(window.innerHeight);\n  canvas.setWidth(window.innerWidth);\n  canvas.renderAll();\n\n  canvasbg.setHeight(window.innerHeight);\n  canvasbg.setWidth(window.innerWidth);\n  canvasbg.renderAll();\n}\n\n// resize on init\nresizeCanvas();\n\n\n\n\ncanvas.isDrawingMode = false;\n//canvas.freeDrawingBrush.width = 5;\n//canvas.freeDrawingBrush.color = '#00aeff';\n\n// function handle_mouse_move(e) {\n//   canvas.freeDrawingBrush._points = e.map((item) => {\n//     return new fabric.Point(item.x, item.y);\n//   });\n//   canvas._onMouseUpInDrawingMode({ target: canvas.upperCanvasEl });\n// }\n\nfunction change_colour_of_brush(colour_taken) {\n  canvas.freeDrawingBrush.color = colour_taken;\n  localStorage.setItem(\"color\",colour_taken);\n}\n\nfunction handle_editing_rectangle(rect_taken) {\n  rect.set({\n    top: rect_taken.top,\n  });\n  rect.set({\n    left: rect_taken.left,\n  });\n  rect.set({\n    width: rect_taken.width,\n  });\n  rect.set({\n    height: rect_taken.height,\n  });\n  canvas.renderAll();\n}\n\nfunction editing_passing_rectangle(rect_taken) {\n  rect = new fabric.Rect(rect_taken);\n  canvas.add(rect);\n  //'canvas.freeDrawingBrush.width = width_taken'\n}\n\nfunction adding_line_to_partner_board(line_taken) {\n  line = new fabric.Line(line_taken, {\n    strokeWidth: 15,\n    fill: \"#07ff11a3\",\n    stroke: \"#07ff11a3\",\n    originX: \"center\",\n    originY: \"center\",\n    selectable: false,\n    objectCaching: false,\n  });\n  //line = new fabric.Line(line_taken)\n  canvas.add(line);\n  //'canvas.freeDrawingBrush.width = width_taken'\n}\n\nfunction editing_added_line_to_board(line_taken) {\n  line.set({\n    x1: line_taken.x1,\n    y1: line_taken.y1,\n    x2: line_taken.x2,\n    y2: line_taken.y2,\n    stroke: line_taken.stroke,\n    fill: line_taken.fill\n  });\n  canvas.renderAll();\n}\n\nfunction width_of_line_passed_taken(width_taken) {\n  // canvas.freeDrawingBrush.width = width_taken;\n}\n\nfunction circle_passed_to_board(circle_taken) {\n  circle.set({\n    radius: circle_taken.radius,\n  });\n  canvas.renderAll();\n}\n\nfunction adding_circle_on_the_board(circle_taken) {\n  circle = new fabric.Circle(circle_taken);\n  canvas.add(circle);\n\n  //'canvas.freeDrawingBrush.width = width_taken'\n}\n\nlet stroke_line = 0;\n\nvar drawing_color_fill = document.getElementById(\"drawing-color-fill\"),\n  drawing_color_border = document.getElementById(\"drawing-color-border\"),\n  drawing_figure_width = document.getElementById(\"drawing-figure-width\"),\n  drawing_figure_opacity = document.getElementById(\"opacity\");\n\n  var  drawingColorEl = document.getElementById(\"drawing-color\"),\n  drawingLineWidthEl = document.getElementById(\"drawing-line-width\");\n        \n/* Basic example */\n\nconst popupBasic = new Picker({parent:drawingColorEl,popup: 'top',editorFormat: 'rgba'});\npopupBasic.onChange = function(color) {\n  drawingColorEl.style.backgroundColor = color.rgbaString;\n  canvas.freeDrawingBrush.color = color.rgbaString;\n  socket.emit(\"color:change\", color.rgbaString);\n  Cookies.set('colour', color.rgbaString);\n\n  // console.log(Cookies.get('colour'));\n  let obj_ = canvas.getActiveObject();\n  // console.log(obj_);\n  if ( obj_ && obj_.changedColour ){\n    socket.emit(\"color:changed\", { \"object\":obj_, \"id\":obj_.id, \"color\":color.rgbaString});\n    obj_.changedColour(color.rgbaString)\n  }\n};\n\n\n//Open the popup manually:\n// popupBasic.openHandler();\n\n\ncanvas.freeDrawingBrush.color = drawingColorEl.style.backgroundColor;\ncanvas.freeDrawingBrush.width = parseInt(drawingLineWidthEl.value, 10);\n\nlet localStorageColour = localStorage.getItem('color');\nlet localStorageWidth  = localStorage.getItem('width');\n\nif (localStorageColour)\n{\n  canvas.freeDrawingBrush.color = localStorageColour;\n  drawingColorEl.style.backgroundColor = localStorageColour;\n}\n\nif (localStorageWidth)\n{\n  canvas.freeDrawingBrush.width = localStorageWidth;\n  drawingLineWidthEl.value = localStorageWidth;\n}\n\n\ndrawingLineWidthEl.oninput = function() \n{\n  canvas.freeDrawingBrush.width = parseInt(drawingLineWidthEl.value, 10);\n  socket.emit(\"width:change\", canvas.freeDrawingBrush.width);\n\n  localStorage.setItem('width',canvas.freeDrawingBrush.width);\n  let obj_ = canvas.getActiveObject();\n  // console.log(obj_);\n  if ( obj_ && obj_.changedWidth ){\n    // console.log(obj_.id);\n    socket.emit(\"width:changed\",{\"object\": obj_, \"id\":obj_.id, \"width\":canvas.freeDrawingBrush.width});\n    obj_.changedWidth(drawingLineWidthEl.value);\n    socket.emit(\"canvas_save_to_json\", {\"board_id\": board_id, \"canvas\": serialize_canvas(canvas)});\n  }\n\n};\n\n\nfunction drawLine(type_of_line) {\n  // canvas.freeDrawingBrush.width = parseInt(drawingLineWidthEl.value, 10);\n  // canvas.freeDrawingBrush.color = drawingColorEl.style.backgroundColor;\n  drawingLineWidthEl.onchange = function() \n  {\n    canvas.freeDrawingBrush.width = parseInt(drawingLineWidthEl.value, 10) ;\n    socket.emit(\"width:change\", canvas.freeDrawingBrush.width);\n  };\n  let line, isDown;\n\n  drawingColorEl.onchange = function() \n  {\n    canvas.freeDrawingBrush.color = drawingColorEl.style.backgroundColor;\n    socket.emit(\"color:change\",drawingColorEl.style.backgroundColor);\n\n    // console.log(\"line!\");\n\n  };\n  colour_inside = hexToRgbA('#000dff',5);\n  if (type_of_line == \"trivial\") { \n    stroke_line   = 0;\n  } else if(type_of_line == \"dotted\") {\n    stroke_line = 20;\n  }else if ( type_of_line == \"arrow\" ){\n    stroke_line = 0;\n  }else if ( type_of_line == \"arrowtwo\" ){\n    stroke_line = 0;\n  }\n\n  removeEvents();\n  changeObjectSelection(false);\n  canvas.on(\"mouse:down\", function (o) {\n    isDown = true;\n    let pointer = canvas.getPointer(o.e);\n    let points = [pointer.x, pointer.y, pointer.x, pointer.y];\n    if ( type_of_line == \"arrow\" ){\n      line = new fabric.Arrow(points, {\n        strokeWidth: parseInt(canvas.freeDrawingBrush.width),//drawing_figure_width.value,\n        //fill: hexToRgbA(drawing_color_fill.value,drawing_figure_opacity.value),\n        stroke: canvas.freeDrawingBrush.color,//hexToRgbA(drawing_color_fill.value, drawing_figure_opacity.value),\n        strokeDashArray: [stroke_line, stroke_line],\n        ///stroke: '#07ff11a3',\n        originX: \"center\",\n        originY: \"center\",\n        selectable: false,\n        objectCaching: false,\n      });\n      \n    }else if ( type_of_line == \"arrowtwo\" ){\n      line = new fabric.ArrowTwo(points, {\n        strokeWidth: parseInt(canvas.freeDrawingBrush.width),//drawing_figure_width.value,\n        //fill: hexToRgbA(drawing_color_fill.value,drawing_figure_opacity.value),\n        stroke: canvas.freeDrawingBrush.color,//hexToRgbA(drawing_color_fill.value, drawing_figure_opacity.value),\n        strokeDashArray: [stroke_line, stroke_line],\n        ///stroke: '#07ff11a3',\n        originX: \"center\",\n        originY: \"center\",\n        selectable: false,\n        objectCaching: false,\n      });\n    }else{\n      line = new fabric.Line(points, {\n        strokeWidth: parseInt(canvas.freeDrawingBrush.width),//drawing_figure_width.value,\n        //fill: hexToRgbA(drawing_color_fill.value,drawing_figure_opacity.value),\n        stroke: canvas.freeDrawingBrush.color,//hexToRgbA(drawing_color_fill.value, drawing_figure_opacity.value),\n        strokeDashArray: [stroke_line, stroke_line],\n        ///stroke: '#07ff11a3',\n        originX: \"center\",\n        originY: \"center\",\n        selectable: false,\n        objectCaching: false,\n      });\n    }\n    line.changedColour = function(color){\n      this.stroke = color;\n      // console.log(\"line stroke\");\n      canvas.renderAll();\n    }\n    line.changedWidth = function(width){\n      line.objectCaching = false;\n      // canvas.freeDrawingBrush.width = parseInt(drawingLineWidthEl.value, 10);\n      this.strokeWidth = parseInt(width);\n      canvas.renderAll();\n    }\n    canvas.add(line);\n    socket.emit(\"line:add\", {\n      id: line.id,\n      points: points,\n      fill:line.fill,\n      width: parseInt(line.strokeWidth),\n      strokeDashArray: [stroke_line, stroke_line],\n      stroke: line.stroke});\n  });\n  canvas.on(\"mouse:move\", function (o) {\n    if (!isDown) return;\n    let pointer = canvas.getPointer(o.e);\n    if ( line!==undefined ){\n      line.set({\n        x2: pointer.x,\n        y2: pointer.y,\n      });\n    }\n    canvas.renderAll();\n    socket.emit(\"line:edit\", {\n      x1: line.x1,\n      y1: line.y1,\n      x2: line.x2,\n      y2: line.y2,\n      stroke: line.stroke,\n      fill: line.fill\n    });\n  });\n\n  canvas.on(\"mouse:up\", function (o) {\n    isDown = false;\n    line.setCoords();\n    //socket.emit(\"canvas_save_to_json\", canvas.toJSON(['id']));\n    // let board_id = get_board_id();\n    socket.emit(\"canvas_save_to_json\", {\"board_id\": board_id, \"canvas\": serialize_canvas(canvas)});\n    //socket.emit(\"canvas_save_to_json\", {\"board_id\": board_id, \"canvas\": canvas.toJSON(['id'])});\n  });\n\n\n  canvas.on('object:removed',function(object){\n    console.warn(object);\n  })\n}\n\n\n\n\nfunction changeObjectSelection(value) {\n  canvas.forEachObject(function (obj) {\n    if ( obj.cursor ===undefined || !obj.cursor ){\n      obj.set({selectable : value});\n    }\n    // console.log(obj.selectable);\n  });\n  canvas.renderAll();\n}\n\nfunction removeEvents() {\n  canvas.isDrawingMode = false;\n  canvas.selection = false;\n  canvas.off(\"mouse:down\");\n  canvas.off(\"mouse:up\");\n  canvas.off(\"mouse:move\");\n  canvas.on(\"mouse:move\", (event) => handleMouseMovement(event))\n\n}\n\nfunction hexToRgbA(hex, figures_opacity) {\n  var c;\n  if (/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)) {\n    c = hex.substring(1).split(\"\");\n    if (c.length == 3) {\n      c = [c[0], c[0], c[1], c[1], c[2], c[2]];\n    }\n    c = \"0x\" + c.join(\"\");\n    return (\n      \"rgba(\" +\n      [(c >> 16) & 255, (c >> 8) & 255, c & 255].join(\",\") +\n      \",\" +\n      figures_opacity / 100 +\n      \")\"\n    );\n  }\n  throw new Error(\"Bad Hex\");\n}\n\nvar drawingOptionsEl = document.getElementById(\"drawing-mode-options-2\");\n\nfunction print_Text() {\n  var textbox = new fabric.Textbox(\"This is a Textbox object\", {\n    left: 20,\n    top: 50,\n    fill: \"#880E4F\",\n    strokeWidth: 2,\n    stroke: \"#D81B60\",\n  });\n\n  canvas.add(textbox);\n  socket.emit(\"canvas_save_to_json\", {\"board_id\": board_id, \"canvas\": serialize_canvas(canvas)});\n  socket.emit(\"text:add\", canvas.toJSON(['id']));\n}\n\nfunction find_object_index(target_object) {\n  let target_index; \n  let objects = canvas.getObjects();\n  objects.forEach(function (object, index) {\n    if (object.id == target_object.id) {\n      target_index = index;\n    }\n  });\n  return target_index;\n}\n\n\nfunction send_part_of_data(e) {\n  if (e.target._objects) {\n    let data = { objects: [] };\n    let json_canvas = canvas.toJSON(['id']);\n    if(e.transform.target.type=='group')\n    {\n        let object_index = find_object_index(e.transform.target);\n        e.transform.target.object_index = find_object_index(e.transform.target);\n        data.objects.push({\n          id: e.transform.target.id,\n          index: object_index,\n          object:e.transform.target,\n          top_all: json_canvas.objects[object_index].top,\n          left_all: json_canvas.objects[object_index].left,\n          angle: json_canvas.objects[object_index].angle,\n          scaleX: json_canvas.objects[object_index].scaleX,\n          scaleY: json_canvas.objects[object_index].scaleY,\n        })\n    }else{   \n      e.transform.target._objects.forEach((object) => {\n        let object_index = find_object_index(object);\n        object.object_index = object_index;\n        data.objects.push({\n          id:object.id,\n          object: object,\n          index: object_index,\n          top_all: json_canvas.objects[object_index].top,\n          left_all: json_canvas.objects[object_index].left,\n          angle: json_canvas.objects[object_index].angle,\n          scaleX: json_canvas.objects[object_index].scaleX,\n          scaleY: json_canvas.objects[object_index].scaleY,\n        });\n      });\n    }\n    socket.emit(\"object:modified\", data);\n  } else {\n    let object_index = find_object_index(e.target);\n\n    e.target.object_index = object_index;\n    socket.emit(\"object:modified\", {\n      //object: e.target,\n      id: canvas._objects[object_index].id,\n      object: canvas._objects[object_index],\n      index: object_index,\n    });\n  }\n}\n\n\nfunction recive_part_of_data(e) {\n  // console.log(e);\n  if (e.objects) {\n    for (const object of e.objects) {\n      //let d = canvas.item(object.index);\n      let d = canvas._objects.find(item=>item.id==object.id);\n      if(!d){\n        continue;\n      }\n      d.set({\n        top: object.top_all, //+object.object.top,\n        left: object.left_all, //+object.object.left\n        angle: object.angle,\n        scaleX: object.scaleX,\n        scaleY: object.scaleY,\n      });\n    }\n  } else {\n    //let d = canvas.item(e.index);\n    let d = canvas._objects.find(item=>item.id==e.id);\n    //d.set(e.object);\n    if(!d){\n      return false\n    }\n    d.set({\n      top: e.object.top, //+object.object.top,\n      left: e.object.left, //+object.object.left\n      angle: e.object.angle,\n      scaleX: e.object.scaleX,\n      scaleY: e.object.scaleY,\n    });\n  }\n  canvas.renderAll();\n}\n\n\ndocument.body.addEventListener('keydown', handleDownKeySpace);\ndocument.body.addEventListener('keyup', handleUpKeySpace);\n\nlet canvasDragModeEnabled = false;\n\nconst handleButtonCursorMoveClick = (ev) => {\n  canvasDragModeEnabled = true;\n  removeEvents();\n  ev.preventDefault()\n  isCursorMove = !isCursorMove;\n  canvas.toggleDragMode(true);\n  buttonCursorMove.classList.toggle('settings-panel__button-cursor-move_active');\n  canvas.isDrawingMode = false\n  canvas.allowTouchScrolling = true;\n  changeObjectSelection(false);\n} \nbuttonCursorMove.addEventListener('click', handleButtonCursorMoveClick);\n\n\nlet colour = Cookies.get('colour');\n\ndocument.addEventListener('DOMContentLoaded',(e)=>{\n  removeEvents();\n  isCursorMove= true;\n  canvas.toggleDragMode(true);\n  buttonCursorMove.classList.add('settings-panel__button-cursor-move_active');\n  selectedTool = buttonCursorMove.dataset.tool;\n  canvas.isDrawingMode = false\n  canvas.allowTouchScrolling = true;\n  changeObjectSelection(false);\n  // console.log(colour);\n  if ( colour ){\n    popupBasic.setColor(colour);\n    drawingColorEl.style.backgroundColor = colour;\n    socket.emit(\"color:change\", colour);\n  }else{\n    colour=\"rgba(0,0,0,1)\";\n    popupBasic.setColor(colour);\n    drawingColorEl.style.backgroundColor = colour;\n    Cookies.set('colour',colour);\n  }\n});\n\n\nconst toolPanelList = document.querySelector('.tool-panel__list');\n\nlet selectedButton = freeDrawingButton;\n\nlet getSiblings = function (e) {\n  // for collecting siblings\n  let siblings = []; \n  // if no parent, return no sibling\n  if(!e.parentNode) {\n      return siblings;\n  }\n  // first child of the parent node\n  let sibling  = e.parentNode.firstChild;\n  // collecting siblings\n  while (sibling) {\n      if (sibling.nodeType === 1 && sibling !== e) {\n          siblings.push(sibling);\n      }\n      sibling = sibling.nextSibling;\n  }\n  return siblings;\n};\n\n\n\ntoolPanelList.addEventListener('click', selectTool)\n\n\ncanvas.on('mouse:out', handleMouseOut);         // Отображение чужих курсоров\ncanvas.on('mouse:move', handleMouseMovement);         // Отображение чужих курсоров\nsocket.on('cursor-data', getCursorData);              // отображаем курсоры чужих пользователей\n\n\nsocket.on('coursour_disconected', function(user_id){\n  let index_of_existing_coursor = canvas._objects.findIndex(item=>item.socket_id==user_id);\n  if (index_of_existing_coursor!==-1){\n    (canvas._objects).splice(index_of_existing_coursor,1);\n    canvas.renderAll();\n  }else{\n    console.log('where is coursour coursour_disconected ')\n  }\n  \n  let index_of_clone_coursor = canvas._objects.findIndex(item=>item.clone_id==`${user_id}_clone`);\n  if (index_of_clone_coursor!==-1){\n    (canvas._objects).splice(index_of_clone_coursor,1);\n    canvas.renderAll();\n  }else{\n    console.log('where is coursour index_of_clone_coursor ')\n  }\n}\n\n);\n\n\n\n\nconst inputChangeColor = document.querySelector('#drawing-line-width');\n// const subToolPanel = inputChangeColor.closest('.sub-tool-panel__change-color');\n\nconst fontColorListWrapper2 = document.querySelector('.setting-item__font-color-list-wrapper');\nconst fontColorInput2 = document.querySelector('.setting-item__input-font-color > input');\n\n\nconst handleClickOpenInputChangeColor = () => {\n\n  // subToolPanel.classList.add('sub-tool-panel_visible');\n}\nconst handleClickCloseInputChangeColor = (event) => {\n  if (event.target !== inputChangeColor) {\n    // subToolPanel.classList.remove('sub-tool-panel_visible');\n\n  } else if(event.target !== fontColorInput2) {\n    fontColorListWrapper2.classList.remove('active');\n  } else {\n\n  }\n}\n\nwindow.addEventListener('click', handleClickCloseInputChangeColor);\ninputChangeColor.addEventListener('click', handleClickOpenInputChangeColor);\n\nfontColorInput2.addEventListener('click', () => { fontColorListWrapper2.classList.add('active') })\n\nfontColorInput2.addEventListener('change', (e) => { \n  let obj_ = canvas.getActiveObject();\n  if ( obj_ ){\n    canvas.getActiveObject().set(\"fill\", e.target.value) \n  }\n})\n\nconst buttonIncreaseScale = document.querySelector(\".scale__button-increase-scale\");\nconst buttonDecreaseScale = document.querySelector(\".scale__button-decrease-scale\");\n\nbuttonIncreaseScale.addEventListener(\"click\", (event) => {\n  event.preventDefault();\n  if((parseFloat(currentValueZoom) + SCALE_STEP*2).toFixed(2) > MAX_ZOOM_IN){\n    return;\n  } else {\n    currentValueZoom = (parseFloat(currentValueZoom) + SCALE_STEP*2).toFixed(2);\n  }\n\n  const center = canvas.getCenter();\n  const centerPoint = new fabric.Point(center.left, center.top);\n  canvas.zoomToPoint(centerPoint, currentValueZoom);\n  canvasbg.zoomToPoint(centerPoint, currentValueZoom);\n  as.textContent = (currentValueZoom * 100).toFixed(0) + '%';\n\n})\n\nbuttonDecreaseScale.addEventListener(\"click\", (event) => {\n  event.preventDefault();\n  if((parseFloat(currentValueZoom) - SCALE_STEP*2).toFixed(2) < MAX_ZOOM_OUT){\n    return;\n  } else {\n    currentValueZoom = (parseFloat(currentValueZoom) - SCALE_STEP*2).toFixed(2);\n  }\n\n  const center = canvas.getCenter();\n  const centerPoint = new fabric.Point(center.left, center.top);\n  canvas.zoomToPoint(centerPoint, currentValueZoom);\n  canvasbg.zoomToPoint(centerPoint, currentValueZoom);\n  as.textContent = (currentValueZoom * 100).toFixed(0) + '%';\n})\n\n\n/**\n * Сравнение объектов\n * https://stackoverflow.com/questions/1068834/object-comparison-in-javascript\n * @param {*} x \n * @param {*} y \n * @returns \n */\nfunction object_equals( x, y ) {\n  if ( x === y ) return true;\n    // if both x and y are null or undefined and exactly the same\n\n  if ( ! ( x instanceof Object ) || ! ( y instanceof Object ) ) return false;\n    // if they are not strictly equal, they both need to be Objects\n\n  if ( x.constructor !== y.constructor ) return false;\n    // they must have the exact same prototype chain, the closest we can do is\n    // test there constructor.\n\n  for ( var p in x ) {\n    if ( ! x.hasOwnProperty( p ) ) continue;\n      // other properties were tested using x.constructor === y.constructor\n\n    if ( ! y.hasOwnProperty( p ) ) return false;\n      // allows to compare x[ p ] and y[ p ] when set to undefined\n\n    if ( x[ p ] === y[ p ] ) continue;\n      // if they have the same strict value or identity then they are equal\n\n    if ( typeof( x[ p ] ) !== \"object\" ) return false;\n      // Numbers, Strings, Functions, Booleans must be strictly equal\n\n    if ( ! object_equals( x[ p ],  y[ p ] ) ) return false;\n      // Objects and Arrays must be tested recursively\n  }\n\n  for ( p in y )\n    if ( y.hasOwnProperty( p ) && ! x.hasOwnProperty( p ) )\n      return false;\n        // allows x[ p ] to be set to undefined\n\n  return true;\n}\n\n/**\n * Назодим тот-же путь\n * @param {*} f \n * @param {*} s \n */\nfunction compare_path(f,s){\n  if ( f.type!='path' || s.type!=f.type )\n    return false\n  if ( f.path.length!=s.path.length )\n    return false\n  if ( !object_equals(f.path,s.path) )\n    return false\n  return true\n}\nsetInterval(function(){\n  let coursours =  canvas._objects.filter(item=>item.socket_id)\n  coursours.forEach(cursor =>{\n    checkCursorClones({\n      cursorCoordinates:{x:cursor.left,y:cursor.top},\n      userId:cursor.socket_id,\n      existing_coursor:cursor\n    })\n\n  })\n\n\n\n},150)\n\nfunction checkCursorClones(data){\n  let cursor_original = canvas._objects.find(item=>item.socket_id==data.userId);\n  if ( data.cursorCoordinates.x< canvas.vptCoords.tl.x || data.cursorCoordinates.x>canvas.vptCoords.tr.x || data.cursorCoordinates.y< canvas.vptCoords.tl.y || data.cursorCoordinates.y>canvas.vptCoords.br.y ){\n    data.cursor='leave';\n\n    let cursor_clone = canvas._objects.find(item=>item.clone_id==`${data.userId}_clone`);\n    if (!cursor_clone){\n      cursor_clone=createCursor();\n      console.log('creating clone of coursor',data.userId,cursor_clone)\n      cursor_clone._objects[1].text = `${data.existing_coursor._objects[1].text}`;\n      cursor_clone.clone_id = `${data.userId}_clone`;\n      canvas._objects[canvas._objects.length]=cursor_clone;\n    }\n    let coords={x:0,y:0}\n    if ( data.cursorCoordinates.x<canvas.vptCoords.tl.x  )    coords.x = canvas.vptCoords.tl.x\n    if ( data.cursorCoordinates.x>canvas.vptCoords.tr.x-90  ) coords.x = canvas.vptCoords.tr.x-90\n    if ( data.cursorCoordinates.y<canvas.vptCoords.tl.y  )    coords.y = canvas.vptCoords.tl.y\n    if ( data.cursorCoordinates.y>canvas.vptCoords.br.y-90  ) coords.y = canvas.vptCoords.br.y-90\n      \n\n      cursor_clone.set({\n        top:  coords.y,\n        left: coords.x,\n        visible: true,\n       // clone_id:`${data.userId}_clone`\n      }); \n      cursor_original.set({\n        visible:false\n      })\n  }\n  else{\n    let cursor_clone    = canvas._objects.find(item=>item.clone_id==`${data.userId}_clone`);\n\n    cursor_original.set({\n      visible:true\n    })\n    if (cursor_clone){\n      cursor_clone.set({\n        visible:false\n      })\n      \n    }else{\n      console.log('where is clone of coursor?')\n    }\n  }  \n\n}\n\n//# sourceURL=webpack://draw_dynamic_3/./public/frontend.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./public/frontend.js"]();
/******/ 	
/******/ })()
;